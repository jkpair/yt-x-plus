#!/usr/bin/env bash
#A script written by Benexl in September 2024 under MIT LICENSE

CLI_NAME="${YT_X_APP_NAME:-yt-x}"
CLI_VERSION="0.4.5"

# ASCII header
CLI_HEADER='
╭──────────────────────────────────────╮
│                                      │
│   ▄▄▄       ▄▄▄▄▄▄▄                  │
│  █▀██  ██  █▀▀██▀▀▀▀                 │
│    ██  ██     ██                     │
│    ██  ██     ██          ▀██ ██▀    │
│    ██  ██     ██     ▀▀▀▀   ███      │
│    ▀█████▄    ▀██▄        ▄██ ██▄    │
│    ▄   ██                            │
│    ▀████▀                            │
│                                      │
│   YouTube from the Terminal  v'"$CLI_VERSION"'  │
╰──────────────────────────────────────╯
'
CLI_AUTHOR="Benexl"
CLI_DIR="$(dirname "$(realpath "$0")")"
CLI_CONFIG_DIR="${XDG_CONFIG_HOME:-"$HOME"/.config}/$CLI_NAME"
CLI_EXTENSION_DIR="$CLI_CONFIG_DIR/extensions"
CLI_THEMES_DIR="$CLI_CONFIG_DIR/themes"
CLI_BUILTIN_THEMES_DIR="$CLI_DIR/themes"
CLI_CACHE_DIR="${XDG_CACHE_HOME:-"$HOME"/.cache}/$CLI_NAME"
CLI_PREVIEW_IMAGES_CACHE_DIR="$CLI_CACHE_DIR/preview_images"
CLI_YT_DLP_ARCHIVE="$CLI_CACHE_DIR/yt-dlp-archive"
CLI_AUTO_GEN_PLAYLISTS="$CLI_CACHE_DIR/playlists"
CLI_PREVIEW_SCRIPTS_DIR="$CLI_CACHE_DIR/preview_text"
[ -d "$CLI_CONFIG_DIR" ] || mkdir -p "$CLI_CONFIG_DIR"
[ -d "$CLI_EXTENSION_DIR" ] || mkdir -p "$CLI_EXTENSION_DIR"
[ -d "$CLI_THEMES_DIR" ] || mkdir -p "$CLI_THEMES_DIR"
[ -d "$CLI_PREVIEW_IMAGES_CACHE_DIR" ] || mkdir -p "$CLI_PREVIEW_IMAGES_CACHE_DIR"
[ -d "$CLI_PREVIEW_SCRIPTS_DIR" ] || mkdir -p "$CLI_PREVIEW_SCRIPTS_DIR"
[ -d "$CLI_YT_DLP_ARCHIVE" ] || mkdir -p "$CLI_YT_DLP_ARCHIVE"
[ -d "$CLI_AUTO_GEN_PLAYLISTS" ] || mkdir -p "$CLI_AUTO_GEN_PLAYLISTS"
CLI_SUPPORT_PROJECT_URL="https://buymeacoffee.com/benexl"

case "$(uname -a)" in
*ndroid) PLATFORM="android" ;;
*Darwin*) PLATFORM="mac" ;;
*MINGW* | *WSL2*) PLATFORM="windows" ;;
*) PLATFORM="linux" ;;
esac

print_config() {
  echo "\
#
#    ██╗░░░██╗████████╗░░░░░░██╗░░██╗  ░█████╗░░█████╗░███╗░░██╗███████╗██╗░██████╗░
#    ╚██╗░██╔╝╚══██╔══╝░░░░░░╚██╗██╔╝  ██╔══██╗██╔══██╗████╗░██║██╔════╝██║██╔════╝░
#    ░╚████╔╝░░░░██║░░░█████╗░╚███╔╝░  ██║░░╚═╝██║░░██║██╔██╗██║█████╗░░██║██║░░██╗░
#    ░░╚██╔╝░░░░░██║░░░╚════╝░██╔██╗░  ██║░░██╗██║░░██║██║╚████║██╔══╝░░██║██║░░╚██╗
#    ░░░██║░░░░░░██║░░░░░░░░░██╔╝╚██╗  ╚█████╔╝╚█████╔╝██║░╚███║██║░░░░░██║╚██████╔╝
#    ░░░╚═╝░░░░░░╚═╝░░░░░░░░░╚═╝░░╚═╝  ░╚════╝░░╚════╝░╚═╝░░╚══╝╚═╝░░░░░╚═╝░╚═════╝░
#

# loads the extension always
# useful for defining changes and overides to the default behaviour
# eg env,ui,functions
# all file names in the extensions folder
AUTO_LOADED_EXTENSIONS: $AUTO_LOADED_EXTENSIONS

# whether to show colors when printing ouput
PRETTY_PRINT: $PRETTY_PRINT

# color theme [everforest-dark-hard/tokyo-night/catppuccin-mocha/gruvbox-dark/dracula]
# themes are loaded from ~/.config/yt-x/themes/ or the built-in themes directory
# see themes/README.md for creating custom themes
THEME: $THEME

# your preferred editor for editing your config
EDITOR: $PREFERRED_EDITOR

# your preferred selector for the tui [fzf/rofi]
PREFERRED_SELECTOR: $PREFERRED_SELECTOR

# the quality of the video when streaming with a player other than mpv
VIDEO_QUALITY: $VIDEO_QUALITY

# whether to show previews [true/false]
# its cool so enable it
ENABLE_PREVIEW: $ENABLE_PREVIEW

# what to use for rendering images in the terminal [chafa/icat/auto]
# auto: uses icat for Kitty/Ghostty terminals, chafa for others
# icat: Kitty graphics protocol (best for Kitty, WezTerm, Ghostty)
# chafa: Universal support (works in most terminals)
IMAGE_RENDERER: $IMAGE_RENDERER

# whether to run mpv as a background process and prevent it from closing even if you terminate the program or terminal session
DISOWN_STREAMING_PROCESS: $DISOWN_STREAMING_PROCESS

# whether to update the recent list kept locally [true/false]
UPDATE_RECENT: $UPDATE_RECENT

# whether to update the recent list kept locally [true/false]
SEARCH_HISTORY: $SEARCH_HISTORY

# the number of recent videos to keep
NO_OF_RECENT: $NO_OF_RECENT

# the player to use for streaming [mpv/vlc]
PLAYER: $PLAYER

# the browser to use to extract cookies from
# this is used by yt-dlp to access content that would require login
PREFERRED_BROWSER: $PREFERRED_BROWSER

# the number of results to get from yt-dlp
NO_OF_SEARCH_RESULTS: $NO_OF_SEARCH_RESULTS

# the duration notifications stay on the screen
NOTIFICATION_DURATION: $NOTIFICATION_DURATION

# where your downloads will be stored
DOWNLOAD_DIRECTORY: $DOWNLOAD_DIRECTORY

# whether to check for updates [true/false]
UPDATE_CHECK: $UPDATE_CHECK

# whether to enable the welcome screeen which runs once a day [true/false]
WELCOME_SCREEN: $WELCOME_SCREEN

# ===== yt-dlp Enhanced Options =====

# skip sponsored segments using SponsorBlock [true/false]
SPONSORBLOCK: $SPONSORBLOCK

# SponsorBlock categories to skip (comma-separated)
# options: sponsor,intro,outro,selfpromo,preview,filler,interaction,music_offtopic,poi_highlight,chapter,all
SPONSORBLOCK_CATS: $SPONSORBLOCK_CATS

# mark videos as watched on YouTube after viewing [true/false]
MARK_WATCHED: $MARK_WATCHED

# download live streams from the start [true/false]
LIVE_FROM_START: $LIVE_FROM_START

# number of concurrent fragment downloads (1-16, higher = faster but uses more bandwidth)
CONCURRENT_FRAGMENTS: $CONCURRENT_FRAGMENTS

# number of retries for failed downloads
DOWNLOAD_RETRIES: $DOWNLOAD_RETRIES

# embed thumbnail in downloaded files [true/false]
EMBED_THUMBNAIL: $EMBED_THUMBNAIL

# embed subtitles in downloaded files [true/false]
EMBED_SUBS: $EMBED_SUBS

# embed chapters/metadata in downloaded files [true/false]
EMBED_CHAPTERS: $EMBED_CHAPTERS

# preferred video codec [av1/vp9/h264/any]
PREFERRED_CODEC: $PREFERRED_CODEC

# prefer HDR content when available [true/false]
PREFER_HDR: $PREFER_HDR

# subtitle languages to download (comma-separated, e.g., en,es,auto)
SUBTITLE_LANGS: $SUBTITLE_LANGS
"
}

find_config_option() {
  local option=$1
  awk -F': ' -v opt="$option" '$0 ~ "^"opt":" && !/^#/ {print $2}' "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
}

# Validate numeric value, returns sanitized number or default
# Usage: validate_numeric "value" "default" "min" "max"
validate_numeric() {
  local value="$1"
  local default="$2"
  local min="${3:-0}"
  local max="${4:-999999}"

  # Strip non-numeric characters
  value="${value//[^0-9]/}"

  # Use default if empty
  [ -z "$value" ] && echo "$default" && return

  # Clamp to range
  [ "$value" -lt "$min" ] && value="$min"
  [ "$value" -gt "$max" ] && value="$max"

  echo "$value"
}

load_config() {
  ! [ -f "$CLI_CONFIG_DIR/${CLI_NAME}.conf" ] && touch "$CLI_CONFIG_DIR/${CLI_NAME}.conf"

  PRETTY_PRINT="$(find_config_option "PRETTY_PRINT")"
  [ -z "$PRETTY_PRINT" ] && PRETTY_PRINT="true"

  THEME="$(find_config_option "THEME")"
  [ -z "$THEME" ] && THEME="everforest-dark-hard"

  IMAGE_RENDERER="$(find_config_option "IMAGE_RENDERER")"
  # Auto-detect best renderer: icat for Kitty/Ghostty, chafa for others
  if [ -z "$IMAGE_RENDERER" ] || [ "$IMAGE_RENDERER" = "auto" ]; then
    if [ -n "$KITTY_WINDOW_ID" ] || [ -n "$GHOSTTY_BIN_DIR" ]; then
      IMAGE_RENDERER="icat"
    else
      IMAGE_RENDERER="chafa"
    fi
  fi

  DISOWN_STREAMING_PROCESS="$(find_config_option "DISOWN_STREAMING_PROCESS")"
  [ -z "$DISOWN_STREAMING_PROCESS" ] && DISOWN_STREAMING_PROCESS="true"

  PREFERRED_EDITOR="$(find_config_option "EDITOR")"
  [ -z "$PREFERRED_EDITOR" ] && PREFERRED_EDITOR=${EDITOR:-open}

  PREFERRED_SELECTOR="$(find_config_option "PREFERRED_SELECTOR")"
  [ -z "$PREFERRED_SELECTOR" ] && PREFERRED_SELECTOR="fzf"

  VIDEO_QUALITY=$(validate_numeric "$(find_config_option "VIDEO_QUALITY")" 1080 144 4320)

  ENABLE_PREVIEW="$(find_config_option "ENABLE_PREVIEW")"
  [ -z "$ENABLE_PREVIEW" ] && ENABLE_PREVIEW="false"

  UPDATE_RECENT="$(find_config_option "UPDATE_RECENT")"
  [ -z "$UPDATE_RECENT" ] && UPDATE_RECENT="true"

  NO_OF_RECENT=$(validate_numeric "$(find_config_option "NO_OF_RECENT")" 30 1 500)

  PLAYER="$(find_config_option "PLAYER")"
  [ -z "$PLAYER" ] && PLAYER='mpv'

  # Detect correct mpv command (mpv or mpv.exe)
  if command -v mpv >/dev/null 2>&1; then
    MPV_CMD="mpv"
  elif command -v mpv.exe >/dev/null 2>&1; then
    MPV_CMD="mpv.exe"
  else
    MPV_CMD="mpv"  # fallback
  fi

  PREFERRED_BROWSER="$(find_config_option "PREFERRED_BROWSER")"
  if [ -n "$PREFERRED_BROWSER" ]; then
    PREFERRED_BROWSER_OPTS=(--cookies-from-browser "$PREFERRED_BROWSER")
    MPV_YTDL_OPTS=(--ytdl-raw-options=cookies-from-browser="$PREFERRED_BROWSER" --ytdl-format="bestvideo+bestaudio/best")
  else
    PREFERRED_BROWSER_OPTS=()
    MPV_YTDL_OPTS=(--ytdl-format="bestvideo+bestaudio/best")
  fi

  NO_OF_SEARCH_RESULTS=$(validate_numeric "$(find_config_option "NO_OF_SEARCH_RESULTS")" 30 1 100)

  NOTIFICATION_DURATION=$(validate_numeric "$(find_config_option "NOTIFICATION_DURATION")" 5 1 30)

  SEARCH_HISTORY="$(find_config_option "SEARCH_HISTORY")"
  [ -z "$SEARCH_HISTORY" ] && SEARCH_HISTORY="true"

  DOWNLOAD_DIRECTORY="$(find_config_option "DOWNLOAD_DIRECTORY")"
  DOWNLOAD_DIRECTORY=${DOWNLOAD_DIRECTORY/#\~/${HOME}}     # expand ~
  DOWNLOAD_DIRECTORY=${DOWNLOAD_DIRECTORY/#\$HOME/${HOME}} # expand $HOME
  [ -z "$DOWNLOAD_DIRECTORY" ] && DOWNLOAD_DIRECTORY="${XDG_VIDEOS_DIR:-"$HOME"/Videos}/$CLI_NAME"
  [ -d "$DOWNLOAD_DIRECTORY" ] || mkdir -p "$DOWNLOAD_DIRECTORY"

  UPDATE_CHECK="$(find_config_option "UPDATE_CHECK")"
  [ -z "$UPDATE_CHECK" ] && UPDATE_CHECK="true"

  WELCOME_SCREEN="$(find_config_option "WELCOME_SCREEN")"
  [ -z "$WELCOME_SCREEN" ] && WELCOME_SCREEN="true"

  ROFI_THEME="$(find_config_option "ROFI_THEME")"
  CUSTOM_PLAYLISTS="$CLI_CONFIG_DIR/custom_playlists.json"
  F_CUSTOM_CMDS="$CLI_CONFIG_DIR/custom_cmds.json"
  PLAYLIST_START="1"
  PLAYLIST_END="$NO_OF_SEARCH_RESULTS"

  # yt-dlp Enhanced Options
  SPONSORBLOCK="$(find_config_option "SPONSORBLOCK")"
  [ -z "$SPONSORBLOCK" ] && SPONSORBLOCK="false"

  SPONSORBLOCK_CATS="$(find_config_option "SPONSORBLOCK_CATS")"
  [ -z "$SPONSORBLOCK_CATS" ] && SPONSORBLOCK_CATS="sponsor,selfpromo"

  MARK_WATCHED="$(find_config_option "MARK_WATCHED")"
  [ -z "$MARK_WATCHED" ] && MARK_WATCHED="false"

  LIVE_FROM_START="$(find_config_option "LIVE_FROM_START")"
  [ -z "$LIVE_FROM_START" ] && LIVE_FROM_START="false"

  CONCURRENT_FRAGMENTS=$(validate_numeric "$(find_config_option "CONCURRENT_FRAGMENTS")" 1 1 16)

  DOWNLOAD_RETRIES=$(validate_numeric "$(find_config_option "DOWNLOAD_RETRIES")" 3 0 10)

  EMBED_THUMBNAIL="$(find_config_option "EMBED_THUMBNAIL")"
  [ -z "$EMBED_THUMBNAIL" ] && EMBED_THUMBNAIL="false"

  EMBED_SUBS="$(find_config_option "EMBED_SUBS")"
  [ -z "$EMBED_SUBS" ] && EMBED_SUBS="false"

  EMBED_CHAPTERS="$(find_config_option "EMBED_CHAPTERS")"
  [ -z "$EMBED_CHAPTERS" ] && EMBED_CHAPTERS="false"

  PREFERRED_CODEC="$(find_config_option "PREFERRED_CODEC")"
  [ -z "$PREFERRED_CODEC" ] && PREFERRED_CODEC="any"

  PREFER_HDR="$(find_config_option "PREFER_HDR")"
  [ -z "$PREFER_HDR" ] && PREFER_HDR="false"

  SUBTITLE_LANGS="$(find_config_option "SUBTITLE_LANGS")"
  [ -z "$SUBTITLE_LANGS" ] && SUBTITLE_LANGS=""

  # Initialize colors and FZF theme
  # User env var YT_X_FZF_OPTS overrides theme settings
  init_pretty_print
  [ -n "$YT_X_FZF_OPTS" ] && FZF_DEFAULT_OPTS="$YT_X_FZF_OPTS"
  AUTO_LOADED_EXTENSIONS="$(awk -F': ' '/^AUTO_LOADED_EXTENSIONS:/ && !/#/ {print $2}' "$CLI_CONFIG_DIR/${CLI_NAME}.conf")"
  if [ -n "$AUTO_LOADED_EXTENSIONS" ]; then
    local IFS=','
    for ext in $AUTO_LOADED_EXTENSIONS; do
      [ -s "$CLI_EXTENSION_DIR/$ext" ] && . "$CLI_EXTENSION_DIR/$ext"
    done
  fi
  if ! [ -s "$CLI_CONFIG_DIR/${CLI_NAME}.conf" ]; then
    print_config >"$CLI_CONFIG_DIR/${CLI_NAME}.conf"
  fi
  export FZF_DEFAULT_OPTS PRETTY_PRINT PLATFORM IMAGE_RENDERER
}

# Build enhanced yt-dlp options based on config
# Populates global array YTDLP_OPTS
build_ytdlp_opts() {
  local mode="${1:-download}"  # download, audio, stream
  YTDLP_OPTS=()

  # SponsorBlock integration
  if [ "$SPONSORBLOCK" = "true" ]; then
    YTDLP_OPTS+=(--sponsorblock-remove "$SPONSORBLOCK_CATS")
  fi

  # Concurrent fragment downloads (for faster downloads)
  if [ "$CONCURRENT_FRAGMENTS" -gt 1 ] 2>/dev/null; then
    YTDLP_OPTS+=(-N "$CONCURRENT_FRAGMENTS")
  fi

  # Download retries
  if [ "$DOWNLOAD_RETRIES" -gt 0 ] 2>/dev/null; then
    YTDLP_OPTS+=(--retries "$DOWNLOAD_RETRIES" --fragment-retries "$DOWNLOAD_RETRIES")
  fi

  # Live stream from start
  if [ "$LIVE_FROM_START" = "true" ]; then
    YTDLP_OPTS+=(--live-from-start)
  fi

  # Mark as watched on YouTube (requires browser cookies)
  if [ "$MARK_WATCHED" = "true" ] && [ "${#PREFERRED_BROWSER_OPTS[@]}" -gt 0 ]; then
    YTDLP_OPTS+=(--mark-watched)
  fi

  # Embedding options (only for downloads, not streams)
  if [ "$mode" = "download" ] || [ "$mode" = "audio" ]; then
    # Sanitize filenames (removes invalid chars, trailing spaces/dots)
    YTDLP_OPTS+=(--windows-filenames)
    if [ "$EMBED_THUMBNAIL" = "true" ]; then
      YTDLP_OPTS+=(--embed-thumbnail)
    fi
    if [ "$EMBED_CHAPTERS" = "true" ]; then
      YTDLP_OPTS+=(--embed-chapters)
    fi
    if [ "$EMBED_SUBS" = "true" ] && [ "$mode" = "download" ]; then
      YTDLP_OPTS+=(--embed-subs)
      if [ -n "$SUBTITLE_LANGS" ]; then
        YTDLP_OPTS+=(--sub-langs "$SUBTITLE_LANGS")
      fi
    fi
  fi

  # Codec preferences (only for video downloads)
  if [ "$mode" = "download" ]; then
    case "$PREFERRED_CODEC" in
      av1)  YTDLP_OPTS+=(--format-sort "vcodec:av1") ;;
      vp9)  YTDLP_OPTS+=(--format-sort "vcodec:vp9") ;;
      h264) YTDLP_OPTS+=(--format-sort "vcodec:h264") ;;
    esac
    if [ "$PREFER_HDR" = "true" ]; then
      YTDLP_OPTS+=(--format-sort "hdr")
    fi
  fi
}

send_notification() {
  echo "$1" >&2 && sleep "$NOTIFICATION_DURATION"
}

# Write to file with locking to prevent race conditions
# Usage: write_file_locked "content" "/path/to/file"
write_file_locked() {
  local content="$1"
  local filepath="$2"
  local lockfile="${filepath}.lock"

  if command -v flock >/dev/null 2>&1; then
    (
      flock -x 200
      echo "$content" > "$filepath"
    ) 200>"$lockfile"
  else
    # Fallback: simple write if flock not available
    echo "$content" > "$filepath"
  fi
}

# Read file with shared lock
# Usage: read_file_locked "/path/to/file"
read_file_locked() {
  local filepath="$1"
  local lockfile="${filepath}.lock"

  if command -v flock >/dev/null 2>&1; then
    (
      flock -s 200
      cat "$filepath"
    ) 200>"$lockfile"
  else
    cat "$filepath"
  fi
}

# Validate JSON and check if it has entries
# Returns 0 if valid JSON with entries, 1 otherwise
validate_json_response() {
  local json="$1"
  local context="${2:-data}"

  if [ -z "$json" ]; then
    echo "Error: Empty response when fetching $context" >&2
    return 1
  fi

  if ! echo "$json" | jq -e '.' >/dev/null 2>&1; then
    echo "Error: Invalid JSON when fetching $context" >&2
    return 1
  fi

  if ! echo "$json" | jq -e '.entries' >/dev/null 2>&1; then
    echo "Error: No entries found in $context" >&2
    return 1
  fi

  return 0
}

# Portable sed in-place edit (works on both GNU and BSD sed)
# Usage: sed_inplace 's/old/new/' file
sed_inplace() {
  local expr="$1"
  local file="$2"
  if sed --version 2>/dev/null | grep -q GNU; then
    sed -i "$expr" "$file"
  else
    # BSD sed requires extension argument
    sed -i '' "$expr" "$file"
  fi
}

# Generate M3U playlist content from JSON data (single jq call instead of 3N+2 subshells)
generate_m3u_content() {
  local json_data="$1"
  echo '#EXTM3U'
  echo "$json_data" | jq -r '.entries[] | "#EXTINF:-1,\(.title)\n\(.url)\n"' 2>/dev/null
}

open_in_editor() {
  local file="$1"
  if command -v "$PREFERRED_EDITOR" >/dev/null 2>&1; then
    "$PREFERRED_EDITOR" "$file"
  elif command -v "$EDITOR" >/dev/null 2>&1; then
    "$EDITOR" "$file"
  elif command -v "open" >/dev/null 2>&1; then
    open "$file"
  elif command -v "xdg-open" >/dev/null 2>&1; then
    xdg-open "$file"
  else
    send_notification "Could not find preferred editor ($PREFERRED_EDITOR) or editor env ($EDITOR) or xdg-open or open"
    return 1
  fi
}

update_script() {
  yt_x_path="$(command -v yt-x)"
  if [ -z "$yt_x_path" ]; then
    send_notification "Can't find yt-x in PATH"
    exit 1
  fi

  if [ ! -w "$yt_x_path" ]; then
    if [ -n "$(command -v sudo)" ]; then
      exec sudo -s "$yt_x_path" "-u"
    else
      send_notification "Insufficient permissions to update and can't find sudo in PATH"
      exit 1
    fi
  fi

  update=$(curl -s "https://raw.githubusercontent.com/Benexl/yt-x/refs/heads/master/yt-x" || byebye 1)
  update="$(printf '%s\n' "$update" | diff -u "$yt_x_path" - 2>/dev/null)"
  if [ -z "$update" ]; then
    send_notification "Script is up to date :)"
  else
    if printf '%s\n' "$update" | patch "$yt_x_path" -; then
      send_notification "Script has been updated!"
    else
      send_notification "Can't update for some reason!"
    fi
  fi
  exec "$yt_x_path"
}

check_update() {
  update=$(curl -s "https://raw.githubusercontent.com/Benexl/yt-x/refs/heads/master/yt-x")
  update="$(printf '%s\n' "$update" | diff -u "$(command -v yt-x)" - 2>/dev/null)"
  if [ -n "$update" ]; then
    confirm "An update has been found would you like to see the changes before deciding whether to update?" && echo "$update" | less
    if [ "$PREFERRED_SELECTOR" = "fzf" ]; then
      answer=$(prompt "$1")
    else
      answer=$(printf "Yes\nNo" | launcher "$1")
    fi
    case "$answer" in
    [Yy]*) update_script ;;
    esac
  fi
}

# Adapted from the preview script in the fzf repo
fzf_preview() {
  file=$1

  dim=${FZF_PREVIEW_COLUMNS}x${FZF_PREVIEW_LINES}
  if [ "$dim" = x ]; then
    dim=$(stty size </dev/tty | awk "{print \$2 \"x\" \$1}")
  fi

  # Helper function to render with icat (Kitty graphics protocol)
  render_icat() {
    if command -v kitten >/dev/null 2>&1; then
      kitten icat --transfer-mode=memory --unicode-placeholder --stdin=no --place="$dim@0x0" "$1" | sed "\$d" | sed "$(printf "\$s/\$/\033[m/")"
    elif command -v icat >/dev/null 2>&1; then
      icat --transfer-mode=memory --unicode-placeholder --stdin=no --place="$dim@0x0" "$1" | sed "\$d" | sed "$(printf "\$s/\$/\033[m/")"
    else
      kitty icat --transfer-mode=memory --unicode-placeholder --stdin=no --place="$dim@0x0" "$1" | sed "\$d" | sed "$(printf "\$s/\$/\033[m/")"
    fi
  }

  # Helper function to render with chafa (universal fallback)
  render_chafa() {
    case "$PLATFORM" in
    android) chafa --clear -s "$dim" "$1" ;;
    windows) chafa --clear -f sixel -s "$dim" "$1" ;;
    *) chafa --clear -s "$dim" "$1" ;;
    esac
    echo
  }

  # Auto-detect best renderer based on terminal
  # Priority: Kitty terminal -> Ghostty -> Explicit config -> chafa fallback

  if [ -n "$KITTY_WINDOW_ID" ]; then
    # Kitty terminal detected - use icat for best image handling
    render_icat "$file"

  elif [ -n "$GHOSTTY_BIN_DIR" ]; then
    # Ghostty terminal - try icat first, fall back to chafa
    if command -v kitten >/dev/null 2>&1 || command -v icat >/dev/null 2>&1; then
      render_icat "$file"
    elif command -v chafa >/dev/null 2>&1; then
      render_chafa "$file"
    fi

  elif [ "$IMAGE_RENDERER" = "icat" ]; then
    # Explicitly configured to use icat
    render_icat "$file"

  elif command -v chafa >/dev/null 2>&1; then
    # Default: use chafa for broad terminal compatibility
    render_chafa "$file"

  elif command -v imgcat >/dev/null; then
    # iTerm2 imgcat
    imgcat -W "${dim%%x*}" -H "${dim##*x}" "$file"

  else
    echo "Please install a terminal image viewer" >&2
    echo "Either icat for kitty terminal or chafa for universal support" >&2
  fi
}

confirm() {
  if command -v "gum" >/dev/null 2>&1; then
    gum confirm "$1"
  else
    echo "$CLI_HEADER" >&2
    printf "%s [y/N]: " "$1" >&2
    read -r CONFIRMED
    case "$CONFIRMED" in
    y | Y)
      return 0
      ;;
    *)
      return 1
      ;;
    esac
  fi
}
launcher() {
  local selection
  case "$(echo "$PREFERRED_SELECTOR" | tr '[:upper:]' '[:lower:]')" in
  rofi)
    if [ -z "$ROFI_THEME" ]; then
      rofi_selection=$(while read -r line; do echo "$line" | sed -r 's/\x1B(\[[0-9;]*[a-zA-Z]|\(B)//g'; done | rofi -sort -matching fuzzy -dmenu -i -width 1500 -p "" -mesg "Select Action" -matching fuzzy -sorting-method fzf)
      [ -z "$rofi_selection" ] && echo "Exit" || echo "$rofi_selection"
    else
      rofi_selection=$(while read -r line; do echo "$line" | sed -r 's/\x1B(\[[0-9;]*[a-zA-Z]|\(B)//g'; done | rofi -no-config -theme "$ROFI_THEME" -sort -matching fuzzy -dmenu -i -width 1500 -p "" -mesg "Select Action" -matching fuzzy -sorting-method fzf)
      [ -z "$rofi_selection" ] && echo "Exit" || echo "$rofi_selection"
    fi
    ;;
  *)
    selection=$(fzf \
      --info=hidden \
      --layout=reverse \
      --height=100% \
      --prompt="${1}: " \
      --header-first --header="$CLI_HEADER" \
      --exact --cycle --ansi)
    # Skip separator lines (lines containing ┈ characters)
    if echo "$selection" | grep -qF '┈'; then
      echo ""
    else
      echo "$selection"
    fi
    ;;
  esac

}

generate_sha256() {
  local input

  # Check if input is passed as an argument or piped
  if [ -n "$1" ]; then
    input="$1"
  else
    input=$(cat)
  fi

  if command -v sha256sum &>/dev/null; then
    echo -n "$input" | sha256sum | awk '{print $1}'
  elif command -v shasum &>/dev/null; then
    echo -n "$input" | shasum -a 256 | awk '{print $1}'
  elif command -v sha256 &>/dev/null; then
    echo -n "$input" | sha256 | awk '{print $1}'
  elif command -v openssl &>/dev/null; then
    echo -n "$input" | openssl dgst -sha256 | awk '{print $2}'
  else
    echo -n "$input" | base64 | tr '/+' '_-' | tr -d '\n'
  fi
}

generate_text_preview() {
  [ -z "$search_results" ] && return 1
  ids="$(echo "$1" | jq '.entries[].id' -r 2>/dev/null)"

  lines="$(echo "$ids" | wc -l)"
  for i in $(seq 1 "$lines"); do
    video=$(echo "$1" | jq ".entries[$((i - 1))]")
    title=$(echo "$video" | jq ".title" -r | sed 's/"/\\\\"/g;s/%/%%/g;s/\$/\\\\$/g;s/^.. //g')
    id=$(echo "$video" | jq '.id' -r)

thumbnail_url=$(echo "$video" | jq '.thumbnails[-1].url' -r)
if [[ "$thumbnail_url" == //* ]]; then
  thumbnail_url="https:$thumbnail_url"
fi
preview_image=$(echo "$thumbnail_url" | generate_sha256)

    view_count=$(
      echo "$video" | jq -r '
      (.view_count // .concurrent_view_count // null)
      | if . == null then "N/A"
        else
          tostring
          |split("")
          |reverse
          |join("")
          |gsub("(?<thousands>[0-9]{3})(?=[0-9])"; "\(.thousands),")
          |split("")
          |reverse
          |join("")
        end
      '
    )

    live_status=$(echo "$video" | jq '.live_status' -r)
    [ "$live_status" = "is_live" ] && live_status='Online'
    [ "$live_status" = "was_live" ] && live_status='Offline'
    [ "$live_status" = "null" ] && live_status='False'

    description=$(echo "$video" | jq '.description' -r | sed "s/\"//g;s/%//g")
    # Try .channel first, then .uploader as fallback
    channel=$(echo "$video" | jq -r '.channel // .uploader // .uploader_id // "Unknown"')

    # some duration calculations
    duration=$(echo "$video" | jq '
    try 
      if .duration>=3600 then
        if .duration/3600|floor == 1 then 
          .duration/3600|floor|tostring + " hour" 
        else 
          .duration/3600|floor|tostring + " hours" 
        end 
      elif .duration>=60 then
        if .duration/60|floor == 1 then 
          .duration/60|floor|tostring + " min" 
        else 
          .duration/60|floor|tostring + " mins" 
        end 
      else 
        if .duration == 1 then 
          .duration/1|floor|tostring + " sec" 
        else 
          .duration/1|floor|tostring + " secs" 
        end 
      end
    catch
      "Unknown" 
    ' -r)

    # some date calculations
    timestamp=$(echo "$video" | jq '.timestamp' -r)
    if [ "$timestamp" = "null" ] || [ -z "$timestamp" ] || ! [[ "$timestamp" =~ ^[0-9]+$ ]]; then
      timestamp="Unknown"
    else
      relative_timestamp=$(("$CURRENT_TIME" - "$timestamp"))
      if [ "$relative_timestamp" -lt 60 ]; then
      timestamp="just now"
    elif [ "$relative_timestamp" -lt 3600 ]; then
      timestamp=$((relative_timestamp / 60))
      if [ "$timestamp" -eq 1 ]; then
        timestamp="$timestamp minute ago"
      else
        timestamp="$timestamp minutes ago"
      fi
    elif [ "$relative_timestamp" -lt 86400 ]; then
      timestamp=$((relative_timestamp / 3600))
      if [ "$relative_timestamp" -lt 7200 ]; then
        timestamp="1 hour ago"
      else
        timestamp=$((relative_timestamp / 3600))
        timestamp="$timestamp hours ago"
      fi
    elif [ "$relative_timestamp" -lt 604800 ]; then
      timestamp=$((relative_timestamp / 86400))
      if [ "$timestamp" -eq 1 ]; then
        timestamp="$timestamp day ago"
      else
        timestamp="$timestamp days ago"
      fi
    elif [ "$relative_timestamp" -lt 2635200 ]; then
      timestamp=$((relative_timestamp / 604800))
      if [ "$timestamp" -eq 1 ]; then
        timestamp="$timestamp week ago"
      else
        timestamp="$timestamp weeks ago"
      fi
    elif [ "$relative_timestamp" -lt 31622400 ]; then
      timestamp=$((relative_timestamp / 2635200))
      if [ "$timestamp" -eq 1 ]; then
        timestamp="$timestamp month ago"
      else
        timestamp="$timestamp months ago"
      fi
    else
      timestamp=$((relative_timestamp / 31622400))
      if [ "$timestamp" -eq 1 ]; then
        timestamp="$timestamp year ago"
      else
        timestamp="$timestamp years ago"
      fi
    fi
    fi

    printf "
# Initialize metadata variables
_channel=\"$channel\"
_view_count=\"$view_count\"
_live_status=\"$live_status\"
_description=\"$description\"

# Fetch missing metadata FIRST (before any rendering) so slow operations complete early
if [ \"\$_channel\" = \"Unknown\" ] || [ \"\$_channel\" = \"null\" ] || [ \"\$_view_count\" = \"N/A\" ]; then
  _cache_file=\"$CLI_CACHE_DIR/metadata_$id.json\"
  if [ -f \"\$_cache_file\" ]; then
    _meta=\$(cat \"\$_cache_file\")
  else
    _meta=\$(yt-dlp \"https://www.youtube.com/watch?v=$id\" -j --no-download --skip-download 2>/dev/null)
    [ -n \"\$_meta\" ] && echo \"\$_meta\" > \"\$_cache_file\"
  fi
  if [ -n \"\$_meta\" ]; then
    [ \"\$_channel\" = \"Unknown\" ] || [ \"\$_channel\" = \"null\" ] && _channel=\$(echo \"\$_meta\" | jq -r '.channel // .uploader // \"Unknown\"')
    if [ \"\$_view_count\" = \"N/A\" ]; then
      _view_count=\$(echo \"\$_meta\" | jq -r '
        .view_count
        | if . == null then \"N/A\"
          else
            tostring
            |split(\"\")
            |reverse
            |join(\"\")
            |gsub(\"(?<thousands>[0-9]{3})(?=[0-9])\"; \"\\(.thousands),\")
            |split(\"\")
            |reverse
            |join(\"\")
          end
      ')
    fi
    [ \"\$_live_status\" = \"False\" ] && _live_status=\$(echo \"\$_meta\" | jq -r '.live_status // \"false\"')
    [ \"\$_description\" = \"null\" ] && _description=\$(echo \"\$_meta\" | jq -r '.description // \"\"')
  fi
fi

# Now render image (after metadata fetch is complete)
if [ -f \"$CLI_PREVIEW_IMAGES_CACHE_DIR/${preview_image}.jpg\" ]; then
  fzf_preview \"$CLI_PREVIEW_IMAGES_CACHE_DIR/${preview_image}.jpg\" 2>/dev/null
else
  echo \"Loading preview image...\"
  echo \"\"
  echo \"Press Ctrl+R to refresh\"
fi

# Move cursor down to line 10 to start text below image area
printf '\\033[10;1H'

# Separator bar below image area
ll=1
printf \"${GRAY}\"
while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"━\" ;(( ll++ ));done;
printf \"${RESET}\"
echo
echo

# Video title
printf \"${CYAN}${BOLD}$title${RESET}\n\";
echo

# Separator
ll=1
printf \"${GRAY}\"
while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
printf \"${RESET}\"
echo

# Video metadata
printf \"${MAGENTA}${BOLD}  Channel:${RESET}    \$_channel\n\";
printf \"${MAGENTA}${BOLD}  Duration:${RESET}   $duration\n\";
if [ \"\$_view_count\" = \"N/A\" ]; then printf \"${MAGENTA}${BOLD}  Views:${RESET}      N/A\n\"; else printf \"${MAGENTA}${BOLD}  Views:${RESET}      \$_view_count views\n\"; fi
printf \"${MAGENTA}${BOLD}  Live:${RESET}       \$_live_status\n\";
printf \"${MAGENTA}${BOLD}  Uploaded:${RESET}   $timestamp\n\";
echo

# Separator before description
ll=1
printf \"${GRAY}\"
while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
printf \"${RESET}\"
echo
echo

# Word-wrap description at word boundaries
if [ -n \"\$_description\" ] && [ \"\$_description\" != \"null\" ]; then
  echo \"\$_description\" | fold -s -w \$FZF_PREVIEW_COLUMNS
fi

# # Re-render image at the end to ensure it shows after metadata fetch completes
# printf '\\033[1;1H'
# if [ -f \"$CLI_PREVIEW_IMAGES_CACHE_DIR/${preview_image}.jpg\" ]; then
#   fzf_preview \"$CLI_PREVIEW_IMAGES_CACHE_DIR/${preview_image}.jpg\" 2>/dev/null
# fi

" >"$CLI_PREVIEW_SCRIPTS_DIR/$(echo "$video" | jq ".title" -r | generate_sha256).txt"

  done
}

download_preview_images() {
  local json_data="$1"
  echo "Generating preview in the background..."
  generate_text_preview "$json_data" &

  local urls_list
  urls_list="$(echo "$json_data" | jq -r '.entries[].thumbnails[-1].url // empty' 2>/dev/null)"
  [ -z "$urls_list" ] && return 1

  [ -f "$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt" ] && rm "$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt"
  while IFS= read -r raw_url; do
    [ -z "$raw_url" ] && continue

    url="$raw_url"
    if [[ "$url" == //* ]]; then
      url="https:$url"
    fi

    filename=$(echo "$url" | generate_sha256)

    if ! [ -s "$CLI_PREVIEW_IMAGES_CACHE_DIR/${filename}.jpg" ]; then
      echo "url = \"$url\"" >>"$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt"
      echo "output = \"$CLI_PREVIEW_IMAGES_CACHE_DIR/${filename}.jpg\"" >>"$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt"
    fi
  done <<< "$urls_list"

  if [ -s "$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt" ]; then
    curl -s -K "$CLI_PREVIEW_IMAGES_CACHE_DIR/previews.txt" 2>/dev/null &
  fi
}

launcher_with_preview() {
  local selection
  case "$PREFERRED_SELECTOR" in
  rofi)
    if [ -z "$ROFI_THEME" ]; then
      rofi_selection=$(while read -r line; do echo "$line" | sed -r 's/\x1B(\[[0-9;]*[a-zA-Z]|\(B)//g'; done | rofi -sort -matching fuzzy -dmenu -i -width 1500 -p "" -mesg "$1" -matching fuzzy -sorting-method fzf)
      [ -z "$rofi_selection" ] && echo "Exit" || echo "$rofi_selection"
    else
      rofi_selection=$(while read -r line; do echo "$line" | sed -r 's/\x1B(\[[0-9;]*[a-zA-Z]|\(B)//g'; done | rofi -no-config -theme "$ROFI_THEME" -sort -matching fuzzy -dmenu -i -p "" -mesg "Select Action" -matching fuzzy -sorting-method fzf)
      [ -z "$rofi_selection" ] && echo "Exit" || echo "$rofi_selection"
    fi
    ;;
  *)
    selection=$(fzf \
      --info=hidden \
      --layout=reverse \
      --height=100% \
      --prompt="${1}: " \
      --header-first --header="$CLI_HEADER" \
      --preview-window=left,35%,wrap \
      --bind='right:accept,resize:refresh-preview,ctrl-r:refresh-preview' \
      --expect=shift-left,shift-right --tabstop=1 \
      --cycle --exact \
      --ansi --preview="$2")
    # Skip separator lines (lines containing ┈ characters)
    # --expect returns key on line 1, selection on line 2
    local key_line selected_line
    key_line=$(echo "$selection" | head -n1)
    selected_line=$(echo "$selection" | tail -n +2)
    if echo "$selected_line" | grep -qF '┈'; then
      echo "$key_line"
    else
      echo "$selection"
    fi
    ;;
  esac

}

# Load a theme file
# Themes define colors, icons, and FZF styling
# Usage: load_theme "theme-name"
load_theme() {
  local theme_name="${1:-everforest-dark-hard}"
  local theme_file=""

  # Search for theme file (user themes take priority)
  if [ -f "$CLI_THEMES_DIR/${theme_name}.theme" ]; then
    theme_file="$CLI_THEMES_DIR/${theme_name}.theme"
  elif [ -f "$CLI_BUILTIN_THEMES_DIR/${theme_name}.theme" ]; then
    theme_file="$CLI_BUILTIN_THEMES_DIR/${theme_name}.theme"
  fi

  if [ -z "$theme_file" ]; then
    echo "Warning: Theme '$theme_name' not found, using defaults" >&2
    return 1
  fi

  # Source the theme file to load variables
  # shellcheck source=/dev/null
  . "$theme_file"

  # Map theme colors to internal color variables
  RED="${COLOR_RED:-\033[38;5;167m}"
  GREEN="${COLOR_GREEN:-\033[38;5;142m}"
  YELLOW="${COLOR_YELLOW:-\033[38;5;179m}"
  BLUE="${COLOR_BLUE:-\033[38;5;109m}"
  MAGENTA="${COLOR_MAGENTA:-\033[38;5;175m}"
  CYAN="${COLOR_CYAN:-\033[38;5;108m}"
  ORANGE="${COLOR_ORANGE:-\033[38;5;173m}"
  PURPLE="${COLOR_MAGENTA:-\033[38;5;175m}"
  GRAY="${COLOR_GRAY:-\033[38;5;102m}"
  WHITE="${COLOR_WHITE:-\033[38;5;223m}"
  BOLD="${STYLE_BOLD:-\033[1m}"
  DIM="${STYLE_DIM:-\033[2m}"
  ITALIC="${STYLE_ITALIC:-\033[3m}"
  RESET="${STYLE_RESET:-\033[0m}"

  # Build FZF options from theme
  if [ -n "$FZF_COLORS" ] && [ -n "$FZF_STYLE" ]; then
    FZF_DEFAULT_OPTS="${FZF_COLORS}${FZF_STYLE}"
  fi

  CURRENT_THEME="$theme_name"
  return 0
}

# List available themes
list_themes() {
  local themes=()
  local f

  # Built-in themes
  if [ -d "$CLI_BUILTIN_THEMES_DIR" ]; then
    shopt -s nullglob
    for f in "$CLI_BUILTIN_THEMES_DIR"/*.theme; do
      [ -f "$f" ] && themes+=("$(basename "${f%.theme}")")
    done
    shopt -u nullglob
  fi

  # User themes
  if [ -d "$CLI_THEMES_DIR" ]; then
    shopt -s nullglob
    for f in "$CLI_THEMES_DIR"/*.theme; do
      [ -f "$f" ] && themes+=("$(basename "${f%.theme}")")
    done
    shopt -u nullglob
  fi

  # Remove duplicates and sort
  printf '%s\n' "${themes[@]}" | sort -u
}

init_pretty_print() {
  if [ "$PRETTY_PRINT" = "true" ]; then
    # Try to load configured theme
    if [ -n "$THEME" ] && load_theme "$THEME"; then
      : # Theme loaded successfully
    else
      # Fallback: Everforest Dark Hard (default theme)
      RED='\033[38;5;167m'        # #e67e80
      GREEN='\033[38;5;142m'      # #a7c080
      YELLOW='\033[38;5;179m'     # #dbbc7f
      BLUE='\033[38;5;109m'       # #7fbbb3
      MAGENTA='\033[38;5;175m'    # #d699b6
      CYAN='\033[38;5;108m'       # #83c092
      ORANGE='\033[38;5;173m'     # #e69875
      PURPLE='\033[38;5;175m'     # #d699b6
      GRAY='\033[38;5;102m'       # #7a8478
      WHITE='\033[38;5;223m'      # #d3c6aa
      BOLD='\033[1m'
      DIM='\033[2m'
      ITALIC='\033[3m'
      RESET='\033[0m'

      # Default FZF theme (Everforest Dark Hard)
      FZF_DEFAULT_OPTS='
        --color=fg:#d3c6aa,fg+:#d3c6aa,bg:#272e33,bg+:#3c4841
        --color=hl:#a7c080,hl+:#a7c080,info:#83c092,marker:#a7c080
        --color=prompt:#e67e80,spinner:#d699b6,pointer:#d699b6,header:#7fbbb3
        --color=border:#4f5b58,label:#d3c6aa,query:#d3c6aa
        --color=gutter:#272e33,scrollbar:#4f5b58
        --border="rounded" --border-label="" --preview-window="border-rounded"
        --prompt="  " --marker=" " --pointer="▌"
        --separator="─" --scrollbar="▐" --info="inline-right"
        --padding="0,1" --margin="0"
      '
      CURRENT_THEME="everforest-dark-hard"
    fi
  else
    RED='' GREEN='' YELLOW='' BLUE='' MAGENTA='' CYAN='' ORANGE='' PURPLE='' GRAY='' WHITE='' BOLD='' DIM='' ITALIC='' RESET=''
    CURRENT_THEME=""
  fi
}

# UI Helper: Print a section header
ui_section() {
  local title="$1"
  echo -e "${GRAY}─────── ${CYAN}${BOLD}$title${RESET} ${GRAY}───────${RESET}"
}

# UI Helper: Print a separator line
ui_separator() {
  echo -e "${GRAY}────────────────────────────${RESET}"
}

welcome() {
  echo -e "${CYAN}┌─────────────────────────────────────────────────┐${RESET}"
  echo -e "${CYAN}│${RESET}  ${BOLD}Welcome back, ${USERNAME:-${USER:-User}}!${RESET}                       ${CYAN}│${RESET}"
  echo -e "${CYAN}├─────────────────────────────────────────────────┤${RESET}"
  echo -e "${CYAN}│${RESET}                                                 ${CYAN}│${RESET}"
  echo -e "${CYAN}│${RESET}  ${DIM}If you enjoy yt-x, consider supporting${RESET}        ${CYAN}│${RESET}"
  echo -e "${CYAN}│${RESET}  ${DIM}the project at:${RESET}                              ${CYAN}│${RESET}"
  echo -e "${CYAN}│${RESET}  ${BLUE}$CLI_SUPPORT_PROJECT_URL${RESET}  ${CYAN}│${RESET}"
  echo -e "${CYAN}│${RESET}                                                 ${CYAN}│${RESET}"
  echo -e "${CYAN}│${RESET}  ${DIM}Disable in config: WELCOME_SCREEN: false${RESET}      ${CYAN}│${RESET}"
  echo -e "${CYAN}└─────────────────────────────────────────────────┘${RESET}"
  echo ""
  if confirm "Open support page?"; then
    xdg-open "$CLI_SUPPORT_PROJECT_URL" 2>/dev/null || open "$CLI_SUPPORT_PROJECT_URL" 2>/dev/null || true
  fi
}

cleanup() {
  # Remove any lock files we created
  rm -f "$CLI_CONFIG_DIR"/*.lock 2>/dev/null
  rm -f "$CLI_CACHE_DIR"/*.lock 2>/dev/null

  # Clean up temporary preview files older than 1 day
  if [ -d "$CLI_PREVIEW_IMAGES_CACHE_DIR" ]; then
    find "$CLI_PREVIEW_IMAGES_CACHE_DIR" -type f -mtime +1 -delete 2>/dev/null
  fi
}

byebye() {
  cleanup
  clear
  local user="${USER:-User}"
  local line1="Thanks for using yt-x"
  local line2="Have a good day, $user"
  local len1=${#line1} len2=${#line2}
  local width=$((len1 > len2 ? len1 : len2))
  local border=$(printf '─%.0s' $(seq 1 $((width + 4))))
  printf "${CYAN}┌%s┐${RESET}\n" "$border"
  printf "${CYAN}│${RESET}  ${DIM}Thanks for using${RESET} ${BOLD}yt-x${RESET}%*s  ${CYAN}│${RESET}\n" $((width - len1)) ""
  printf "${CYAN}│${RESET}  ${DIM}Have a good day,${RESET} %s%*s  ${CYAN}│${RESET}\n" "$user" $((width - len2)) ""
  printf "${CYAN}└%s┘${RESET}\n" "$border"
  exit "${1:-0}"
}
prompt() {
  HISTORY=$(tail -n 10 "$CLI_CACHE_DIR/search_history.txt" 2>/dev/null | grep -v '^\s*$' | tac | nl -w2 -s'. ')
  HISTORY_TEXT="${GRAY}┈┈┈┈┈┈┈┈┈${RESET} ${DIM}Search Filters${RESET} ${GRAY}┈┈┈┈┈┈┈┈┈${RESET}
${CYAN}Date:${RESET}    :hour  :today  :week  :month  :year
${CYAN}Type:${RESET}    :video  :movie  :live  :short
${CYAN}Quality:${RESET} :hd  :4k  :hdr  :subtitles  :360  :vr
${CYAN}Sort:${RESET}    :newest  :views  :rating
${GRAY}┈┈┈┈┈┈┈┈┈${RESET} ${DIM}Search History${RESET} ${GRAY}┈┈┈┈┈┈┈┈┈${RESET}
$HISTORY
${GRAY}┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈${RESET}
${DIM}Enter !<n> to select from history${RESET}"
  if [ "$PREFERRED_SELECTOR" = "rofi" ]; then
    if [ "$PROMPT_CONTEXT" = "Search" ] && [ "$SEARCH_HISTORY" = "true" ] && [ -n "$HISTORY" ]; then
      rofi -dmenu \
        -p "$1" \
        -mesg "$(printf "\nSearch history:\n%s\n(Enter !&lt;n&gt; to select from history. Example: !1)\n" "$HISTORY")" \
        <<<""
      PROMPT_CONTEXT=""
    else
      rofi -dmenu -p "$1: "
    fi
  elif command -v "gum" >/dev/null 2>&1; then
    if [ "$PROMPT_CONTEXT" = "Search" ] && [ "$SEARCH_HISTORY" = "true" ] && [ -n "$HISTORY" ]; then
      #Combine the YT-X header with the search history
      HEADER_WITH_HISTORY=$(echo -e "$CLI_HEADER\n$HISTORY_TEXT")
      gum input --header "$HEADER_WITH_HISTORY" --prompt "$1: " --value "$2"
      PROMPT_CONTEXT=""
    else
      gum input --header "$CLI_HEADER" --prompt "$1: " --value "$2"
    fi
  else
    echo "$CLI_HEADER" >&2
    if [ "$PROMPT_CONTEXT" = "Search" ] && [ "$SEARCH_HISTORY" = "true" ] && [ -n "$HISTORY" ]; then
      echo -e "$HISTORY_TEXT" >&2
      PROMPT_CONTEXT=""
    fi
    printf "%s: " "$1" >&2
    read -r VAL
    echo "$VAL"
  fi
}
run_yt_dlp() {
  local result
  local playlist_range_opts=()
  if ! is_youtube_feed "$1"; then
    playlist_range_opts=(--playlist-start "$PLAYLIST_START" --playlist-end "$PLAYLIST_END")
  elif [ -n "$2" ]; then
    # Optional entry limit for feeds (e.g. refresh only needs first page)
    playlist_range_opts=(--playlist-end "$2")
  fi
  if command -v "gum" >/dev/null 2>&1; then
    result=$(gum spin --show-output -- yt-dlp "$1" -J --flat-playlist --extractor-args youtubetab:approximate_date "${playlist_range_opts[@]}" "${PREFERRED_BROWSER_OPTS[@]}" 2>/dev/null)
  else
    echo "Loading..." >&2
    result=$(yt-dlp "$1" -J --flat-playlist --extractor-args youtubetab:approximate_date "${playlist_range_opts[@]}" "${PREFERRED_BROWSER_OPTS[@]}" 2>/dev/null)
  fi

  if ! validate_json_response "$result" "playlist data"; then
    send_notification "Failed to fetch data"
    echo '{"entries":[]}'
    return 1
  fi

  echo "$result"
}

is_youtube_feed() {
  case "$1" in
    *"/feed/"*|"https://www.youtube.com"|"ytsearch"*) return 0 ;;
    *) return 1 ;;
  esac
}

core_dep_ch() {
  ! command -v "yt-dlp" >/dev/null 2>&1 && echo "Error: yt-dlp is not installed. Please install it to proceed." >&2 && exit 1
  ! command -v "jq" >/dev/null 2>&1 && echo "Error: jq is not installed. Please install it to proceed." >&2 && exit 1
  ! command -v "fzf" >/dev/null 2>&1 && echo "Error: fzf is not installed. Please install it to proceed." >&2 && exit 1
}

check_ytdlp_version() {
  local installed latest
  installed="$(yt-dlp --version 2>/dev/null)" || return 1
  latest="$(curl -s --max-time 3 https://pypi.org/pypi/yt-dlp/json 2>/dev/null | jq -r '.info.version' 2>/dev/null)" || return 1
  [[ -z "$latest" || "$latest" == "null" ]] && return 1

  if [[ "$installed" == "$latest" ]]; then
    printf '%b\n' "${GREEN}yt-dlp is up to date ($installed)${RESET}"
    return 0
  else
    printf '%b\n' "${YELLOW}yt-dlp is outdated (installed: $installed, latest: $latest). Consider updating.${RESET}"
    return 1
  fi
}

# Detect Linux distribution
detect_distro() {
  if [ -f /etc/os-release ]; then
    . /etc/os-release
    DISTRO_ID="${ID:-unknown}"
    DISTRO_ID_LIKE="${ID_LIKE:-}"
    DISTRO_NAME="${PRETTY_NAME:-$ID}"
  elif [ -f /etc/lsb-release ]; then
    . /etc/lsb-release
    DISTRO_ID="${DISTRIB_ID,,}"
    DISTRO_NAME="${DISTRIB_DESCRIPTION:-$DISTRIB_ID}"
  elif command -v lsb_release >/dev/null 2>&1; then
    DISTRO_ID="$(lsb_release -si | tr '[:upper:]' '[:lower:]')"
    DISTRO_NAME="$(lsb_release -sd)"
  else
    DISTRO_ID="unknown"
    DISTRO_NAME="Unknown Linux Distribution"
  fi

  # Normalize distro ID for package manager detection
  case "$DISTRO_ID" in
    arch|cachyos|endeavouros|manjaro|garuda|artix|arcolinux)
      PKG_MANAGER="pacman"
      PKG_INSTALL="sudo pacman -S --noconfirm"
      PKG_UPDATE="sudo pacman -Sy"
      AUR_HELPER=""
      if command -v yay >/dev/null 2>&1; then
        AUR_HELPER="yay"
      elif command -v paru >/dev/null 2>&1; then
        AUR_HELPER="paru"
      fi
      ;;
    debian|ubuntu|linuxmint|pop|elementary|zorin|kali|raspbian|neon)
      PKG_MANAGER="apt"
      PKG_INSTALL="sudo apt install -y"
      PKG_UPDATE="sudo apt update"
      ;;
    fedora|rhel|centos|rocky|alma|nobara)
      PKG_MANAGER="dnf"
      PKG_INSTALL="sudo dnf install -y"
      PKG_UPDATE="sudo dnf check-update"
      ;;
    opensuse*|suse|sles)
      PKG_MANAGER="zypper"
      PKG_INSTALL="sudo zypper install -y"
      PKG_UPDATE="sudo zypper refresh"
      ;;
    gentoo|funtoo)
      PKG_MANAGER="emerge"
      PKG_INSTALL="sudo emerge --ask=n"
      PKG_UPDATE="sudo emerge --sync"
      ;;
    void)
      PKG_MANAGER="xbps"
      PKG_INSTALL="sudo xbps-install -y"
      PKG_UPDATE="sudo xbps-install -S"
      ;;
    alpine)
      PKG_MANAGER="apk"
      PKG_INSTALL="sudo apk add"
      PKG_UPDATE="sudo apk update"
      ;;
    nixos)
      PKG_MANAGER="nix"
      PKG_INSTALL="nix-env -iA nixpkgs."
      PKG_UPDATE=""
      ;;
    *)
      # Try to detect by ID_LIKE
      case "$DISTRO_ID_LIKE" in
        *arch*)
          PKG_MANAGER="pacman"
          PKG_INSTALL="sudo pacman -S --noconfirm"
          PKG_UPDATE="sudo pacman -Sy"
          ;;
        *debian*|*ubuntu*)
          PKG_MANAGER="apt"
          PKG_INSTALL="sudo apt install -y"
          PKG_UPDATE="sudo apt update"
          ;;
        *fedora*|*rhel*)
          PKG_MANAGER="dnf"
          PKG_INSTALL="sudo dnf install -y"
          PKG_UPDATE="sudo dnf check-update"
          ;;
        *)
          PKG_MANAGER="unknown"
          PKG_INSTALL=""
          PKG_UPDATE=""
          ;;
      esac
      ;;
  esac
}

# Get package name for a dependency based on distro
get_pkg_name() {
  local dep="$1"
  case "$PKG_MANAGER" in
    pacman)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;  # icat comes with kitty
        *) echo "$dep" ;;
      esac
      ;;
    apt)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum (via: sudo mkdir -p /etc/apt/keyrings && curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg && echo 'deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *' | sudo tee /etc/apt/sources.list.d/charm.list && sudo apt update)" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    dnf)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum (via: echo '[charm]' | sudo tee /etc/yum.repos.d/charm.repo && echo 'name=Charm' | sudo tee -a /etc/yum.repos.d/charm.repo && echo 'baseurl=https://repo.charm.sh/yum/' | sudo tee -a /etc/yum.repos.d/charm.repo && echo 'enabled=1' | sudo tee -a /etc/yum.repos.d/charm.repo && echo 'gpgcheck=1' | sudo tee -a /etc/yum.repos.d/charm.repo && echo 'gpgkey=https://repo.charm.sh/yum/gpg.key' | sudo tee -a /etc/yum.repos.d/charm.repo)" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    zypper)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum (install via go: go install github.com/charmbracelet/gum@latest)" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    xbps)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    apk)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    emerge)
      case "$dep" in
        yt-dlp) echo "net-misc/yt-dlp" ;;
        jq) echo "app-misc/jq" ;;
        fzf) echo "app-shells/fzf" ;;
        mpv) echo "media-video/mpv" ;;
        vlc) echo "media-video/vlc" ;;
        ffmpeg) echo "media-video/ffmpeg" ;;
        chafa) echo "media-gfx/chafa" ;;
        rofi) echo "x11-misc/rofi" ;;
        gum) echo "app-misc/gum (or: go install github.com/charmbracelet/gum@latest)" ;;
        curl) echo "net-misc/curl" ;;
        icat) echo "x11-terms/kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    nix)
      case "$dep" in
        yt-dlp) echo "yt-dlp" ;;
        jq) echo "jq" ;;
        fzf) echo "fzf" ;;
        mpv) echo "mpv" ;;
        vlc) echo "vlc" ;;
        ffmpeg) echo "ffmpeg" ;;
        chafa) echo "chafa" ;;
        rofi) echo "rofi" ;;
        gum) echo "gum" ;;
        curl) echo "curl" ;;
        icat) echo "kitty" ;;
        *) echo "$dep" ;;
      esac
      ;;
    *)
      echo "$dep"
      ;;
  esac
}

# Print colored status
print_status() {
  local name="$1"
  local status="$2"
  local info="$3"
  local required="$4"

  local GREEN='\033[0;32m'
  local RED='\033[0;31m'
  local YELLOW='\033[0;33m'
  local CYAN='\033[0;36m'
  local BOLD='\033[1m'
  local NC='\033[0m'

  if [ "$PRETTY_PRINT" != "true" ]; then
    GREEN=""
    RED=""
    YELLOW=""
    CYAN=""
    BOLD=""
    NC=""
  fi

  local req_label=""
  if [ "$required" = "required" ]; then
    req_label="${RED}[REQUIRED]${NC}"
  else
    req_label="${CYAN}[optional]${NC}"
  fi

  if [ "$status" = "installed" ]; then
    printf "  ${GREEN}✓${NC} ${BOLD}%-12s${NC} %-30s %s\n" "$name" "$info" "$req_label"
  else
    printf "  ${RED}✗${NC} ${BOLD}%-12s${NC} ${YELLOW}%-30s${NC} %s\n" "$name" "NOT INSTALLED" "$req_label"
  fi
}

# Check a single dependency
check_dep() {
  local cmd="$1"
  local required="$2"

  if command -v "$cmd" >/dev/null 2>&1; then
    local version=""
    case "$cmd" in
      yt-dlp) version="$($cmd --version 2>/dev/null | head -1)" ;;
      jq) version="$($cmd --version 2>/dev/null)" ;;
      fzf) version="$($cmd --version 2>/dev/null | head -1)" ;;
      mpv) version="$($cmd --version 2>/dev/null | head -1 | awk '{print $2}')" ;;
      vlc) version="$($cmd --version 2>/dev/null | head -1 | awk '{print $3}')" ;;
      ffmpeg) version="$($cmd -version 2>/dev/null | head -1 | awk '{print $3}')" ;;
      chafa) version="$($cmd --version 2>/dev/null | head -1 | awk '{print $2}')" ;;
      rofi) version="$($cmd -version 2>/dev/null | head -1)" ;;
      gum) version="$($cmd --version 2>/dev/null)" ;;
      curl) version="$($cmd --version 2>/dev/null | head -1 | awk '{print $2}')" ;;
      kitten) version="(icat available)" ;;
      *) version="installed" ;;
    esac
    print_status "$cmd" "installed" "${version:-installed}" "$required"
    return 0
  else
    print_status "$cmd" "missing" "NOT INSTALLED" "$required"
    return 1
  fi
}

# Comprehensive dependency check with verbose output
check_dependencies() {
  local GREEN='\033[0;32m'
  local RED='\033[0;31m'
  local YELLOW='\033[0;33m'
  local CYAN='\033[0;36m'
  local BOLD='\033[1m'
  local NC='\033[0m'

  if [ "$PRETTY_PRINT" != "true" ]; then
    GREEN=""
    RED=""
    YELLOW=""
    CYAN=""
    BOLD=""
    NC=""
  fi

  detect_distro

  echo ""
  echo "${BOLD}╭────────────────────────────────────────────────────────────────╮${NC}"
  echo "${BOLD}│              $CLI_NAME Dependency Check v$CLI_VERSION                 │${NC}"
  echo "${BOLD}╰────────────────────────────────────────────────────────────────╯${NC}"
  echo ""
  echo "${CYAN}System Information:${NC}"
  echo "  Distribution: ${BOLD}$DISTRO_NAME${NC}"
  echo "  Package Manager: ${BOLD}$PKG_MANAGER${NC}"
  [ -n "$AUR_HELPER" ] && echo "  AUR Helper: ${BOLD}$AUR_HELPER${NC}"
  echo ""

  local missing_required=()
  local missing_optional=()

  echo "${CYAN}Required Dependencies:${NC}"
  echo "  These are essential for $CLI_NAME to function."
  echo ""

  check_dep "yt-dlp" "required" || missing_required+=("yt-dlp")
  check_dep "jq" "required" || missing_required+=("jq")
  check_dep "fzf" "required" || missing_required+=("fzf")
  check_dep "mpv" "required" || missing_required+=("mpv")
  check_dep "ffmpeg" "required" || missing_required+=("ffmpeg")
  check_dep "curl" "required" || missing_required+=("curl")

  echo ""
  echo "${CYAN}Optional Dependencies:${NC}"
  echo "  These enable additional features."
  echo ""

  check_dep "vlc" "optional" || missing_optional+=("vlc")
  check_dep "rofi" "optional" || missing_optional+=("rofi")
  check_dep "chafa" "optional" || missing_optional+=("chafa")
  check_dep "gum" "optional" || missing_optional+=("gum")

  # Check for icat (comes with kitty)
  if command -v kitten >/dev/null 2>&1; then
    print_status "icat" "installed" "(via kitty)" "optional"
  else
    print_status "icat" "missing" "NOT INSTALLED" "optional"
    missing_optional+=("icat")
  fi

  echo ""
  echo "${CYAN}Font Requirements:${NC}"
  echo "  A Nerd Font is recommended for proper icon display."
  echo "  Download from: https://www.nerdfonts.com/"
  echo ""

  # Summary
  echo "${BOLD}────────────────────────────────────────────────────────────────────${NC}"

  if [ ${#missing_required[@]} -eq 0 ]; then
    echo "${GREEN}✓ All required dependencies are installed!${NC}"
  else
    echo "${RED}✗ Missing required dependencies: ${missing_required[*]}${NC}"
  fi

  if [ ${#missing_optional[@]} -gt 0 ]; then
    echo "${YELLOW}! Missing optional dependencies: ${missing_optional[*]}${NC}"
  fi

  echo ""

  # Show install commands if there are missing dependencies
  if [ ${#missing_required[@]} -gt 0 ] || [ ${#missing_optional[@]} -gt 0 ]; then
    echo "${CYAN}Installation Commands:${NC}"
    echo ""

    if [ "$PKG_MANAGER" = "unknown" ]; then
      echo "${YELLOW}Could not detect package manager.${NC}"
      echo "Please install the missing packages manually."
    else
      if [ ${#missing_required[@]} -gt 0 ]; then
        echo "${BOLD}Required packages:${NC}"
        local pkgs=""
        for dep in "${missing_required[@]}"; do
          local pkg_name
          pkg_name=$(get_pkg_name "$dep")
          pkgs="$pkgs $pkg_name"
        done
        echo "  $PKG_INSTALL$pkgs"
        echo ""
      fi

      if [ ${#missing_optional[@]} -gt 0 ]; then
        echo "${BOLD}Optional packages:${NC}"
        for dep in "${missing_optional[@]}"; do
          local pkg_name
          pkg_name=$(get_pkg_name "$dep")
          echo "  $PKG_INSTALL $pkg_name"
        done
        echo ""
      fi
    fi

    echo "${CYAN}Or run: ${BOLD}$CLI_NAME --install${NC} to install missing dependencies automatically"
    echo ""
  fi

  return ${#missing_required[@]}
}

# Install missing dependencies
install_dependencies() {
  local GREEN='\033[0;32m'
  local RED='\033[0;31m'
  local YELLOW='\033[0;33m'
  local CYAN='\033[0;36m'
  local BOLD='\033[1m'
  local NC='\033[0m'

  if [ "$PRETTY_PRINT" != "true" ]; then
    GREEN=""
    RED=""
    YELLOW=""
    CYAN=""
    BOLD=""
    NC=""
  fi

  detect_distro

  echo ""
  echo "${BOLD}╭────────────────────────────────────────────────────────────────╮${NC}"
  echo "${BOLD}│            $CLI_NAME Dependency Installer v$CLI_VERSION              │${NC}"
  echo "${BOLD}╰────────────────────────────────────────────────────────────────╯${NC}"
  echo ""
  echo "${CYAN}System Information:${NC}"
  echo "  Distribution: ${BOLD}$DISTRO_NAME${NC}"
  echo "  Package Manager: ${BOLD}$PKG_MANAGER${NC}"
  [ -n "$AUR_HELPER" ] && echo "  AUR Helper: ${BOLD}$AUR_HELPER${NC}"
  echo ""

  if [ "$PKG_MANAGER" = "unknown" ]; then
    echo "${RED}Error: Could not detect package manager.${NC}"
    echo "Please install dependencies manually."
    echo ""
    echo "Required: yt-dlp, jq, fzf, mpv, ffmpeg, curl"
    echo "Optional: vlc, rofi, chafa, gum, kitty (for icat)"
    exit 1
  fi

  # Collect missing dependencies
  local missing_required=()
  local missing_optional=()

  command -v yt-dlp >/dev/null 2>&1 || missing_required+=("yt-dlp")
  command -v jq >/dev/null 2>&1 || missing_required+=("jq")
  command -v fzf >/dev/null 2>&1 || missing_required+=("fzf")
  command -v mpv >/dev/null 2>&1 || missing_required+=("mpv")
  command -v ffmpeg >/dev/null 2>&1 || missing_required+=("ffmpeg")
  command -v curl >/dev/null 2>&1 || missing_required+=("curl")

  command -v vlc >/dev/null 2>&1 || missing_optional+=("vlc")
  command -v rofi >/dev/null 2>&1 || missing_optional+=("rofi")
  command -v chafa >/dev/null 2>&1 || missing_optional+=("chafa")
  command -v gum >/dev/null 2>&1 || missing_optional+=("gum")

  if [ ${#missing_required[@]} -eq 0 ] && [ ${#missing_optional[@]} -eq 0 ]; then
    echo "${GREEN}✓ All dependencies are already installed!${NC}"
    exit 0
  fi

  echo "${CYAN}Missing required dependencies:${NC} ${missing_required[*]:-None}"
  echo "${CYAN}Missing optional dependencies:${NC} ${missing_optional[*]:-None}"
  echo ""

  # Ask what to install
  echo "What would you like to install?"
  echo "  1) Required dependencies only"
  echo "  2) All dependencies (required + optional)"
  echo "  3) Cancel"
  echo ""
  read -rp "Enter choice [1-3]: " choice

  local to_install=()

  case "$choice" in
    1)
      to_install=("${missing_required[@]}")
      ;;
    2)
      to_install=("${missing_required[@]}" "${missing_optional[@]}")
      ;;
    *)
      echo "Installation cancelled."
      exit 0
      ;;
  esac

  if [ ${#to_install[@]} -eq 0 ]; then
    echo "${GREEN}Nothing to install!${NC}"
    exit 0
  fi

  echo ""
  echo "${CYAN}Installing: ${to_install[*]}${NC}"
  echo ""

  # Update package database first
  if [ -n "$PKG_UPDATE" ]; then
    echo "${CYAN}Updating package database...${NC}"
    eval "$PKG_UPDATE" || true
    echo ""
  fi

  # Install packages
  local failed=()

  for dep in "${to_install[@]}"; do
    local pkg_name
    pkg_name=$(get_pkg_name "$dep")

    # Skip packages that need special handling
    if [[ "$pkg_name" == *"via:"* ]] || [[ "$pkg_name" == *"install via"* ]]; then
      echo "${YELLOW}! $dep requires manual installation:${NC}"
      echo "  $pkg_name"
      echo ""
      failed+=("$dep")
      continue
    fi

    echo "${CYAN}Installing $dep ($pkg_name)...${NC}"

    if [ "$PKG_MANAGER" = "nix" ]; then
      if ! nix-env -iA "nixpkgs.$pkg_name" 2>/dev/null; then
        failed+=("$dep")
      fi
    else
      if ! eval "$PKG_INSTALL $pkg_name"; then
        failed+=("$dep")
      fi
    fi
    echo ""
  done

  # Summary
  echo "${BOLD}────────────────────────────────────────────────────────────────────${NC}"

  if [ ${#failed[@]} -eq 0 ]; then
    echo "${GREEN}✓ All packages installed successfully!${NC}"
  else
    echo "${YELLOW}! Some packages failed to install: ${failed[*]}${NC}"
    echo "You may need to install them manually."
  fi

  echo ""
  echo "Run ${BOLD}$CLI_NAME --check-deps${NC} to verify installation."
  echo ""
}

# Install yt-x to system
install_self() {
  local GREEN='\033[0;32m'
  local RED='\033[0;31m'
  local YELLOW='\033[0;33m'
  local CYAN='\033[0;36m'
  local BOLD='\033[1m'
  local NC='\033[0m'

  if [ "$PRETTY_PRINT" != "true" ]; then
    GREEN=""
    RED=""
    YELLOW=""
    CYAN=""
    BOLD=""
    NC=""
  fi

  local install_dir="${1:-/usr/local/bin}"
  local script_path
  script_path="$(realpath "$0")"

  echo ""
  echo "${BOLD}╭────────────────────────────────────────────────────────────────╮${NC}"
  echo "${BOLD}│               $CLI_NAME System Installer v$CLI_VERSION               │${NC}"
  echo "${BOLD}╰────────────────────────────────────────────────────────────────╯${NC}"
  echo ""

  # Check if we need sudo
  local use_sudo=""
  if [ ! -w "$install_dir" ]; then
    use_sudo="sudo"
    echo "${YELLOW}Note: Installation to $install_dir requires sudo privileges.${NC}"
    echo ""
  fi

  echo "${CYAN}This will:${NC}"
  echo "  1. Copy $CLI_NAME to $install_dir/$CLI_NAME"
  echo "  2. Make it executable"
  if [ -d "$CLI_DIR/themes" ]; then
    echo "  3. Copy themes to $install_dir/../share/$CLI_NAME/themes"
  fi
  echo ""

  read -rp "Proceed with installation? [y/N]: " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "Installation cancelled."
    exit 0
  fi

  echo ""

  # Create install directory if needed
  if [ ! -d "$install_dir" ]; then
    echo "${CYAN}Creating $install_dir...${NC}"
    $use_sudo mkdir -p "$install_dir"
  fi

  # Copy script
  echo "${CYAN}Installing $CLI_NAME to $install_dir...${NC}"
  if $use_sudo cp "$script_path" "$install_dir/$CLI_NAME" && $use_sudo chmod +x "$install_dir/$CLI_NAME"; then
    echo "${GREEN}✓ $CLI_NAME installed to $install_dir/$CLI_NAME${NC}"
  else
    echo "${RED}✗ Failed to install $CLI_NAME${NC}"
    exit 1
  fi

  # Copy themes if they exist
  if [ -d "$CLI_DIR/themes" ]; then
    local themes_dest="$install_dir/../share/$CLI_NAME/themes"
    echo "${CYAN}Installing themes to $themes_dest...${NC}"
    $use_sudo mkdir -p "$themes_dest"
    if $use_sudo cp -r "$CLI_DIR/themes/"* "$themes_dest/"; then
      echo "${GREEN}✓ Themes installed${NC}"
    else
      echo "${YELLOW}! Failed to copy themes (not critical)${NC}"
    fi
  fi

  echo ""
  echo "${GREEN}✓ Installation complete!${NC}"
  echo ""
  echo "You can now run ${BOLD}$CLI_NAME${NC} from anywhere."
  echo "Run ${BOLD}$CLI_NAME --check-deps${NC} to verify dependencies."
  echo ""
}
trap cleanup EXIT
trap byebye INT TERM
PREVIEW_SCRIPT_FOR_VIDEOS="

  title={}
  id=\$(echo {} | generate_sha256)
  if  [ -f \"$CLI_PREVIEW_SCRIPTS_DIR/\${id}.txt\" ];then
    . \"$CLI_PREVIEW_SCRIPTS_DIR/\${id}.txt\";
  else
    echo Loading Preview...
  fi
"
PREVIEW_SCRIPT_FOR_CHANNELS="

  MAGENTA='\x1b[38;2;215;0;95m'
  BOLD=\$(tput bold)
  RESET=\$(tput sgr0)

  if ! [ -z {} ] && ! [ {} = \"Back\" ] && ! [ {} = \"Exit\" ] && ! [ {} = \"Main Menu\" ];then
    channels_data=\$(cat \"\$CLI_CONFIG_DIR/subscriptions.json\")
    title=\"\$(echo {}|sed 's/\"/\\\\\\\"/g')\"
    video=\$(echo \"\$channels_data\" | jq -r \".entries | map(select(.title == \\\"\$title\\\" )) | .[0]\" 2>/dev/null)

    id=\$(echo \$video |jq '.thumbnails[-1].url' -r | generate_sha256);

    channel=\$(echo \"\$video\"| jq '.channel' -r);

    channel_follower_count=\$(echo \"\$video\"| jq -r '
    .channel_follower_count
    |tostring
    |split(\"\")
    |reverse
    |join(\"\")
    |gsub(\"(?<thousands>[0-9]\\{3})(?=[0-9])\"; \"\\(.thousands),\")
    |split(\"\")
    |reverse
    |join(\"\")
    '
    );
    
    description=\$(echo \"\$video\"| jq '.description' -r);
    
    if [ -f \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" ];then fzf_preview \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" 2>/dev/null;
    else echo \"Loading preview image...\"; echo \"Press Ctrl+R to refresh\";
    fi

    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
    # printf \"\${MAGENTA}\${BOLD}Id: \${RESET}\$id\n\";
    printf \"\${MAGENTA}\${BOLD}Channel: \${RESET}\$channel\n\";
    printf \"\${MAGENTA}\${BOLD}Follower Count: \${RESET}\$channel_follower_count followers\n\";

    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
    ! [ \"\$description\" = \"null\" ] && echo -e \"\$description\";
  else
    echo Loading...;
  fi;
"

PREVIEW_SCRIPT_FOR_CHANNELS_EXPLORER="

  MAGENTA='\x1b[38;2;215;0;95m'
  BOLD=\$(tput bold)
  RESET=\$(tput sgr0)

  if ! [ -z {} ] && ! [ {} = \"Back\" ] && ! [ {} = \"Exit\" ] && ! [ {} = \"Main Menu\" ];then
    # channels_data=\$(cat \"\$CLI_CONFIG_DIR/subscriptions.json\")
    title=\"\$(echo {}|sed 's/\"/\\\\\\\"/g')\"
    video=\$(echo \"\$channels_data\" | jq -r \".entries | map(select(.title == \\\"\$title\\\" )) | .[0]\" 2>/dev/null)

    id=\$(echo \$video | jq '.thumbnails[-1].url' -r | generate_sha256);   

    channel=\$(echo \"\$video\"| jq '.channel' -r);

    channel_follower_count=\$(echo \"\$video\"| jq -r '
    .channel_follower_count
    |tostring
    |split(\"\")
    |reverse
    |join(\"\")
    |gsub(\"(?<thousands>[0-9]\\{3})(?=[0-9])\"; \"\\(.thousands),\")
    |split(\"\")
    |reverse
    |join(\"\")
    '
    );
    
    description=\$(echo \"\$video\"| jq '.description' -r);
    
    if [ -f \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" ];then fzf_preview \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" 2>/dev/null;
    else echo \"Loading preview image...\"; echo \"Press Ctrl+R to refresh\";
    fi

    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
    # printf \"\${MAGENTA}\${BOLD}Id: \${RESET}\$id\n\";
    printf \"\${MAGENTA}\${BOLD}Channel: \${RESET}\$channel\n\";
    printf \"\${MAGENTA}\${BOLD}Follower Count: \${RESET}\$channel_follower_count followers\n\";

    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
    ! [ \"\$description\" = \"null\" ] && echo -e \"\$description\";
  else
    echo Loading...;
  fi;
"
PREVIEW_SCRIPT_FOR_PLAYLISTS_EXPLORER="

  MAGENTA='\x1b[38;2;215;0;95m'
  BOLD=\$(tput bold)
  RESET=\$(tput sgr0)

  if ! [ -z {} ] && ! [ {} = \"Back\" ] && ! [ {} = \"Exit\" ] && ! [ {} = \"Main Menu\" ];then
    # channels_data=\$(cat \"\$CLI_CONFIG_DIR/subscriptions.json\")
    title=\"\$(echo {}|sed 's/\"/\\\\\\\"/g')\"
    video=\$(echo \"\$playlist_results\" | jq -r \".entries | map(select(.title == \\\"\$title\\\" )) | .[0]\" 2>/dev/null)
    title=\"\$(echo \"\$title\"|sed 's/^.. //g')\"

    id=\$(echo \$video | jq '.thumbnails[-1].url' -r | generate_sha256);   

    
    if [ -f \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" ];then fzf_preview \"$CLI_PREVIEW_IMAGES_CACHE_DIR/\${id}.jpg\" 2>/dev/null;
    else echo \"Loading preview image...\"; echo \"Press Ctrl+R to refresh\";
    fi

    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
      echo \"\$title\";
    ll=1
    while [ \$ll -le \$FZF_PREVIEW_COLUMNS ];do echo -n -e \"─\" ;(( ll++ ));done;
  else
    echo Loading...;
  fi;
"

playlist_explorer() {
  SHELL="bash"
  DOWNLOAD_IMAGES=0
  local feed_page=1
  local feed_all_results=""
  local is_feed=0
  local is_homepage=0
  is_youtube_feed "$url" && is_feed=1
  [ "$url" = "https://www.youtube.com" ] && is_homepage=1
  [ "$is_feed" = 1 ] && feed_all_results="$search_results"
  [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] playlist_explorer: url=$url, is_feed=$is_feed, is_homepage=$is_homepage" >&2
  [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] initial entries: $(echo "$search_results" | jq '.entries | length')" >&2
  while true; do
    if [ "$is_feed" = 1 ]; then
      # For feeds: slice accumulated results to show current page
      local start_idx=$(( (feed_page - 1) * NO_OF_SEARCH_RESULTS ))
      [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] Slicing: page=$feed_page, start_idx=$start_idx, count=$NO_OF_SEARCH_RESULTS" >&2
      [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] feed_all_results has $(echo "$feed_all_results" | jq '.entries | length') entries" >&2
      local display_results
      display_results=$(echo "$feed_all_results" | jq --argjson start "$start_idx" --argjson count "$NO_OF_SEARCH_RESULTS" '
        .entries = (.entries[$start:$start + $count])
      ')
      [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] display_results has $(echo "$display_results" | jq '.entries | length') entries" >&2
      [ "$DOWNLOAD_IMAGES" = 0 ] &&
        search_results=$(echo "$display_results" | jq "
            .entries=(.entries
            | to_entries
            | map(.value.title=\"\(.key+1+$start_idx|tostring| if (.|length) < 2 then \"0\" + . else . end) \"+.value.title)
            |map(.value))
            ") && ! [ "$ENABLE_PREVIEW" = "true" ] || ! [ "$PREFERRED_SELECTOR" = "fzf" ] && DOWNLOAD_IMAGES=1
    else
      [ "$DOWNLOAD_IMAGES" = 0 ] &&
        search_results=$(echo "$search_results" | jq "
            .entries=(.entries
            | to_entries
            | map(.value.title=\"\(.key+1|tostring| if (.|length) < 2 then \"0\" + . else . end) \"+.value.title)
            |map(.value))
            ") && ! [ "$ENABLE_PREVIEW" = "true" ] || ! [ "$PREFERRED_SELECTOR" = "fzf" ] && DOWNLOAD_IMAGES=1
    fi
    titles=$(echo "$search_results" | jq '.entries[].title' -r 2>/dev/null)
    [ "$ENABLE_PREVIEW" = "true" ] && [ "$PREFERRED_SELECTOR" = "fzf" ] && [ "$DOWNLOAD_IMAGES" = 0 ] && download_preview_images "$search_results" && DOWNLOAD_IMAGES=1
    export search_results SHELL
    local nav_options
    if [ "$is_homepage" = 1 ]; then
      nav_options="Refresh"
    else
      nav_options="Next\nPrevious"
    fi
    if [ "$ENABLE_PREVIEW" = "true" ]; then
      title="$(printf "%s\n${nav_options}\n${CYAN}󰌍${RESET}  Back\n${CYAN}󰍜${RESET}  Main Menu\n${RED}󰈆${RESET}  Exit" "$titles" | launcher_with_preview "select video" "$PREVIEW_SCRIPT_FOR_VIDEOS" | tr -d '\n' | sed 's/^[^0-9]  //g')"
    else
      title="$(printf "%s\n${nav_options}\nBack\nMain Menu\nExit" "$titles" | launcher "select video" | tr -d '\n' | sed 's/^[^0-9]  //g')"
    fi
    clear
    title="$(echo "$title" | sed 's/"/\\"/g')"
    case "$title" in
    Next)
      if [ "$is_feed" = 1 ]; then
        feed_page=$((feed_page + 1))
        local needed_entries=$((feed_page * NO_OF_SEARCH_RESULTS))
        local have_entries
        have_entries=$(echo "$feed_all_results" | jq '.entries | length')
        [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] Next: feed_page=$feed_page, have=$have_entries, need=$needed_entries" >&2
        if [ "$have_entries" -lt "$needed_entries" ]; then
          PLAYLIST_START=1
          PLAYLIST_END="$needed_entries"
          [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] Fetching more: PLAYLIST_END=$PLAYLIST_END" >&2
          local new_results
          new_results=$(run_yt_dlp "$url")
          local new_count
          new_count=$(echo "$new_results" | jq '.entries | length')
          [ -n "$YT_X_DEBUG" ] && echo "[DEBUG] After fetch: $new_count entries" >&2
          # Check if we actually got more entries
          local page_start=$(( (feed_page - 1) * NO_OF_SEARCH_RESULTS ))
          if [ "$new_count" -le "$page_start" ]; then
            # Can't fill the next page - revert and notify
            feed_page=$((feed_page - 1))
            echo "No more content available" >&2
            sleep 2
            continue
          fi
          feed_all_results="$new_results"
        fi
        DOWNLOAD_IMAGES=0
      else
        PLAYLIST_START=$((PLAYLIST_START + "$NO_OF_SEARCH_RESULTS"))
        PLAYLIST_END=$((PLAYLIST_END + "$NO_OF_SEARCH_RESULTS"))
        search_results=$(run_yt_dlp "$url")
        DOWNLOAD_IMAGES=0
      fi
      continue
      ;;
    Refresh)
      # Reload the homepage feed with fresh content (limit to one page)
      local refresh_results
      if refresh_results=$(run_yt_dlp "$url" "$NO_OF_SEARCH_RESULTS"); then
        search_results="$refresh_results"
        feed_all_results="$search_results"
        feed_page=1
        DOWNLOAD_IMAGES=0
      else
        send_notification "Refresh failed, keeping current feed"
      fi
      continue
      ;;
    Previous)
      if [ "$is_feed" = 1 ]; then
        [ "$feed_page" -gt 1 ] && feed_page=$((feed_page - 1))
        DOWNLOAD_IMAGES=0
      else
        PLAYLIST_START=$((PLAYLIST_START - "$NO_OF_SEARCH_RESULTS"))
        [ $PLAYLIST_START -le 0 ] && PLAYLIST_START=1
        PLAYLIST_END=$((PLAYLIST_END - "$NO_OF_SEARCH_RESULTS"))
        [ $PLAYLIST_END -le "$NO_OF_SEARCH_RESULTS" ] && PLAYLIST_END="$NO_OF_SEARCH_RESULTS"
        search_results=$(run_yt_dlp "$url")
        DOWNLOAD_IMAGES=0
      fi
      continue
      ;;
    "Main Menu")
      break
      ;;
    Back | "")
      break
      ;;
    Exit)
      byebye
      ;;
    esac
    id=$(echo "$title" | sed -E 's/^([0-9]+) .*/\1/g')
    # Strip leading zeros to avoid octal interpretation (08, 09 would fail)
    id=$((10#$id))
    if [ "$is_feed" = 1 ]; then
      local page_start=$(( (feed_page - 1) * NO_OF_SEARCH_RESULTS ))
      video="$(echo "$search_results" | jq ".entries[$((id - 1 - page_start))]")"
    else
      video="$(echo "$search_results" | jq ".entries[$((id - 1))]")"
    fi
    title=$(echo "$video" | jq '.title' -r | sed 's/^[0-9]\+ //g')

    while true; do
      media_action="$(printf "\
${GREEN}󰐎${RESET}  Watch
${GREEN}󰐊${RESET}  Play All
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Audio${RESET} ${GRAY}┈┈┈┈┈┈┈┈${RESET}
${CYAN}󰎆${RESET}  Listen
${CYAN}󰲸${RESET}  Listen To All
${CYAN}󰒟${RESET}  Mix
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Library${RESET} ${GRAY}┈┈┈┈┈┈┈${RESET}
${BLUE}󰃀${RESET}  Save
${BLUE}󰧎${RESET}  UnSave
${BLUE}󰐒${RESET}  Save Playlist
${BLUE}󰵀${RESET}  Subscribe To Channel
${GRAY}┈┈┈┈┈┈${RESET} ${DIM}Download${RESET} ${GRAY}┈┈┈┈┈┈┈${RESET}
${ORANGE}󱑤${RESET}  Download
${ORANGE}󰦗${RESET}  Download All
${ORANGE}󱑤${RESET}  Download (Audio Only)
${ORANGE}󰦗${RESET}  Download All (Audio Only)
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Other${RESET} ${GRAY}┈┈┈┈┈┈┈┈${RESET}
${PURPLE}󰖟${RESET}  Open in Browser
${PURPLE}󰆏${RESET}  Copy Link
${PURPLE}󰃻${RESET}  Toggle Enumerate Downloads
${PURPLE}󰆍${RESET}  Shell
${GRAY}┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈${RESET}
${RED}󰌍${RESET}  Back
${RED}󰈆${RESET}  Exit" | launcher "Select Media Action" | sed 's/^.[[:space:]]*//; s/[[:space:]]*$//' | xargs -r)"
      clear
      case "$media_action" in
      "Play All")
        if echo "$url" | grep -q "list=RD" || echo "$urlForAll" | grep -q "list=RD" || [ "$(echo "$search_results" | jq 'has("uploader_url") | not')" = "true" ]; then
          if [ -n "$urlForAll" ]; then
            # Fix YouTube Mix URLs FIRST
            url="${url/&start_radio=0/}"
            urlForAll="${urlForAll/&start_radio=1/}"
            cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "$urlForAll").m3u8"
            if ! [ -s "$cached_playlist" ]; then
              _mix_data=$(yt-dlp "$urlForAll" --flat-playlist -J)
              [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
              generate_m3u_content "$_mix_data" >"$cached_playlist"
            fi
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist"
          else
            cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "$url").m3u8"

            if ! [ -s "$cached_playlist" ]; then
              _mix_data=$(yt-dlp "$url" --flat-playlist -J)
              [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
              generate_m3u_content "$_mix_data" >"$cached_playlist"
            fi
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist"
          fi
        else
          if [ -n "$urlForAll" ]; then
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$urlForAll"
          else
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$url"
          fi
        fi
        ;;
      "Listen To All")
        if echo "$url" | grep -q "list=RD" || echo "$urlForAll" | grep -q "list=RD" || [ "$(echo "$search_results" | jq 'has("uploader_url") | not')" = "true" ]; then
          if [ -n "$urlForAll" ]; then
            cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "$urlForAll").m3u8"
            if ! [ -s "$cached_playlist" ]; then
              _mix_data=$(yt-dlp "$urlForAll" --flat-playlist -J)
              [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
              generate_m3u_content "$_mix_data" >"$cached_playlist"
            fi
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist" --no-video --force-window=no
          else
            cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "$url").m3u8"
            if ! [ -s "$cached_playlist" ]; then
              _mix_data=$(yt-dlp "$url" --flat-playlist -J)
              [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
              generate_m3u_content "$_mix_data" >"$cached_playlist"
            fi
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist" --no-video --force-window=no
          fi
        else
          if [ -n "$urlForAll" ]; then
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$urlForAll" --no-video --force-window=no
          else
            "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$url" --no-video --force-window=no
          fi
        fi
        ;;
      "Toggle Enumerate Downloads")
        if [ "$enumerate_playlist" = "" ]; then
          enumerate_playlist="%(playlist_index)s - "
        else
          enumerate_playlist=""
        fi
        ;;
      "Download All")
        playlist_name=$(prompt "Name of the playlist" "$playlist_title")
        build_ytdlp_opts download
        if [ -n "$urlForAll" ]; then
          yt_dlp_cmd=("yt-dlp" "$urlForAll" "--output" "$DOWNLOAD_DIRECTORY/videos/$playlist_name/%(channel)s/$enumerate_playlist%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}")
          "${yt_dlp_cmd[@]}" --download-archive "$CLI_YT_DLP_ARCHIVE/$(echo -n -- "${yt_dlp_cmd[@]}" | generate_sha256)"
        else
          yt_dlp_cmd=("yt-dlp" "$url" "--output" "$DOWNLOAD_DIRECTORY/videos/$playlist_name/%(channel)s/$enumerate_playlist%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}")
          "${yt_dlp_cmd[@]}" --download-archive "$CLI_YT_DLP_ARCHIVE/$(echo -n -- "${yt_dlp_cmd[@]}" | generate_sha256)"
        fi
        send_notification "Completed downloading of $playlist_name"
        ;;
      "Download All (Audio Only)")
        playlist_name=$(prompt "Name of the playlist" "$playlist_title")
        build_ytdlp_opts audio
        if [ -n "$urlForAll" ]; then
          yt_dlp_cmd=("yt-dlp" "$urlForAll" "--audio-format" "mp3" '-x' '-f' 'bestaudio/best' "--output" "$DOWNLOAD_DIRECTORY/audio/$playlist_name/%(channel)s/$enumerate_playlist%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}")
          "${yt_dlp_cmd[@]}" --download-archive "$CLI_YT_DLP_ARCHIVE/$(echo -n -- "${yt_dlp_cmd[@]}" | generate_sha256)"
        else
          yt_dlp_cmd=("yt-dlp" "$url" "--audio-format" "mp3" '-x' '-f' 'bestaudio/best' "--output" "$DOWNLOAD_DIRECTORY/audio/$playlist_name/%(channel)s/$enumerate_playlist%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}")
          "${yt_dlp_cmd[@]}" --download-archive "$CLI_YT_DLP_ARCHIVE/$(echo -n -- "${yt_dlp_cmd[@]}" | generate_sha256)"
        fi
        send_notification "Completed downloading of $playlist_name"
        ;;
      Listen)
        printf "${MAGENTA}Now Listening to:${RESET} $title\n"
        video_url=$(echo "$video" | jq '.url' -r)
        if echo "$video_url" | grep -q "list=RD"; then
          video_id=$(echo "$video" | jq '.id' -r | sed 's/RD//g')
          cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "https://www.youtube.com/watch?v=${video_id}&list=RD$video_id").m3u8"
          if ! [ -s "$cached_playlist" ]; then
            _mix_data=$(yt-dlp "https://www.youtube.com/watch?v=${video_id}&list=RD$video_id" --flat-playlist -J)
            [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
            generate_m3u_content "$_mix_data" >"$cached_playlist"
          fi
          "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist" --no-video --force-window=no
        else
          if ! [ "$PLAYER" = mpv ] || [ "$PLATFORM" = android ]; then
            video_url=$(yt-dlp "$video_url" -q --no-warnings "${PREFERRED_BROWSER_OPTS[@]}" --get-url --format "bestaudio/best[height<=$VIDEO_QUALITY]/best" 2>/dev/null)
            video_url=$(echo "$video_url" | tail -n 1)
            if [ -z "$video_url" ]; then
              echo "No video format found" >&2
              sleep 5
              break
            fi
          fi
          case "$PLATFORM" in
          android)
            case "$PLAYER" in
            mpv) nohup am start --user 0 -a android.intent.action.VIEW -d "$video_url" -n is.xyz.mpv/.MPVActivity >/dev/null 2>&1 & ;;
            vlc) nohup am start --user 0 -a android.intent.action.VIEW -d "$video_url" -n org.videolan.vlc/org.videolan.vlc.gui.video.VideoPlayerActivity -e "title" "$title" >/dev/null 2>&1 & ;;
            esac
            ;;
          *)
            case "$PLAYER" in
            mpv)
              "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$video_url" --no-video --force-window=no
              ;;
            vlc) vlc "$video_url" --video-title "$title" ;;
            esac
            ;;
          esac

        fi

        current_recent_videos='{"entries":[]}'
        [ -s "$CLI_CONFIG_DIR/recent.json" ] && current_recent_videos=$(read_file_locked "$CLI_CONFIG_DIR/recent.json")
        updated_recent=$(echo "$current_recent_videos" | jq --argjson newvideo "$video" --argjson limit "$NO_OF_RECENT" '
          ($newvideo | .title |= sub("^[0-9]+ "; "")) as $v |
          {entries: ([.entries[] | select(.id != $v.id)] + [$v])[-$limit:]}
        ')
        write_file_locked "$updated_recent" "$CLI_CONFIG_DIR/recent.json"
        ;;
      Mix)
        local url0 _search_results
        video_id=$(echo "$video" | jq '.id' -r)
        url0=$urlForAll
        urlForAll="https://www.youtube.com/watch?v=${video_id}&list=RD$video_id"

        _search_results="$search_results"
        search_results=$(
          if command -v "gum" >/dev/null 2>&1; then
            gum spin --show-output -- yt-dlp "$urlForAll" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" "${PLAYLISTS_EXTRA_ARGS[@]}" --playlist-start 1 --playlist-end "$NO_OF_SEARCH_RESULTS"
          else
            echo "Loading..." >&2
            yt-dlp "$urlForAll" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" "${PLAYLISTS_EXTRA_ARGS[@]}" --playlist-start 1 --playlist-end "$NO_OF_SEARCH_RESULTS"
          fi
        )
        playlist_explorer
        urlForAll=$url0
        search_results="$_search_results"
        ;;
      "Watch")
        printf "${MAGENTA}Now watching:${RESET} $title\n"

        video_url=$(echo "$video" | jq '.url' -r)
        if echo "$video_url" | grep -q "list=RD"; then
          local _mix_data
          video_id=$(echo "$video" | jq '.id' -r | sed 's/RD//g')

          cached_playlist="$CLI_AUTO_GEN_PLAYLISTS/$(generate_sha256 "https://www.youtube.com/watch?v=${video_id}&list=RD$video_id").m3u8"

          if ! [ -s "$cached_playlist" ]; then
            _mix_data=$(yt-dlp "https://www.youtube.com/watch?v=${video_id}&list=RD$video_id" "${PREFERRED_BROWSER_OPTS[@]}" --flat-playlist -J)
            [ -z "$_mix_data" ] && send_notification "Failed to get mix data" && continue
            generate_m3u_content "$_mix_data" >"$cached_playlist"
          fi
          "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$cached_playlist"
        else
          if ! [ "$PLAYER" = mpv ] || [ "$PLATFORM" = android ]; then
            video_url=$(yt-dlp "$video_url" -q --no-warnings "${PREFERRED_BROWSER_OPTS[@]}" --get-url 2>/dev/null) #--format "best[height<=$VIDEO_QUALITY]/best"
            video_url=$(echo "$video_url" | tail -n 1)
            if [ -z "$video_url" ]; then
              echo No video format found >&2
              sleep 5
              break
            fi
          fi
          case "$PLATFORM" in
          android)
            case "$PLAYER" in
            mpv) nohup am start --user 0 -a android.intent.action.VIEW -d "$video_url" -n is.xyz.mpv/.MPVActivity >/dev/null 2>&1 & ;;
            vlc) nohup am start --user 0 -a android.intent.action.VIEW -d "$video_url" -n org.videolan.vlc/org.videolan.vlc.gui.video.VideoPlayerActivity -e "title" "$title" >/dev/null 2>&1 & ;;
            esac
            ;;
          *)
            case "$PLAYER" in
            mpv)
              "$MPV_CMD" "${MPV_YTDL_OPTS[@]}" "$video_url"
              ;;
            vlc) vlc "$video_url" --video-title "$title" ;;
            esac
            ;;
          esac

        fi

        current_recent_videos='{"entries":[]}'
        [ -s "$CLI_CONFIG_DIR/recent.json" ] && current_recent_videos=$(read_file_locked "$CLI_CONFIG_DIR/recent.json")
        updated_recent=$(echo "$current_recent_videos" | jq --argjson newvideo "$video" --argjson limit "$NO_OF_RECENT" '
          ($newvideo | .title |= sub("^[0-9]+ "; "")) as $v |
          {entries: ([.entries[] | select(.id != $v.id)] + [$v])[-$limit:]}
        ')
        write_file_locked "$updated_recent" "$CLI_CONFIG_DIR/recent.json"
        ;;
      Save)
        # For now a pseudo like feature is just as useful
        current_liked_videos='{"entries":[]}'
        [ -s "$CLI_CONFIG_DIR/saved_videos.json" ] && current_liked_videos=$(read_file_locked "$CLI_CONFIG_DIR/saved_videos.json")
        updated_saved=$(echo "$current_liked_videos" | jq --argjson newvideo "$video" '
          ($newvideo | .title |= sub("^[0-9]+ "; "")) as $v |
          {entries: ([.entries[] | select(.id != $v.id)] + [$v])}
        ')
        write_file_locked "$updated_saved" "$CLI_CONFIG_DIR/saved_videos.json"
        ;;
      Save\ Playlist)
        custom_playlists="[]"
        [ -s "$CLI_CONFIG_DIR/custom_playlists.json" ] && custom_playlists=$(cat "$CLI_CONFIG_DIR/custom_playlists.json")
        playlist_name=$(prompt "Enter the name of the playlist" "$playlist_title")
        if [ -n "$urlForAll" ]; then
          playlist_id=$(echo "$urlForAll" | sed 's/.*list=//g')
        else
          playlist_id=$(echo "$url" | sed 's/.*list=//g')
        fi
        echo "$custom_playlists" | jq --arg name "$playlist_name" --arg pid "$playlist_id" \
          '. += [{name: $name, playlistUrl: ("https://www.youtube.com/playlist?list=" + $pid), playlistWatchUrl: ("https://www.youtube.com/watch?list=" + $pid)}]' \
          >"$CLI_CONFIG_DIR/custom_playlists.json" && send_notification "successfully added to custom playlists" || send_notification "Failed to add to custom playlists"
        ;;
      UnSave)
        current_liked_videos='{"entries":[]}'
        [ -s "$CLI_CONFIG_DIR/saved_videos.json" ] && current_liked_videos=$(read_file_locked "$CLI_CONFIG_DIR/saved_videos.json")
        id=$(echo "$video" | jq -r '.id')
        updated_saved=$(echo "$current_liked_videos" | jq --arg id "$id" '{entries: [.entries[] | select(.id != $id)]}')
        write_file_locked "$updated_saved" "$CLI_CONFIG_DIR/saved_videos.json"
        ;;
      "Subscribe To Channel")
        # TODO: use youtube api to enable video subscriptions
        send_notification "contribute to the project by adding this feature"
        sleep "$NOTIFICATION_DURATION"
        ;;
      "Open in Browser")
        if command -v "open" >/dev/null 2>&1; then
          open "$(echo "$video" | jq '.url' -r)"
        elif command -v "xdg-open" >/dev/null 2>&1; then
          xdg-open "$(echo "$video" | jq '.url' -r)"
        else
          send_notification "Could not find xdg-open or open"
        fi
        ;;
      "Copy Link")
        local video_link
        video_link="$(echo "$video" | jq '.url' -r)"
        if command -v "wl-copy" >/dev/null 2>&1; then
          printf '%s' "$video_link" | wl-copy
          send_notification "Link copied to clipboard"
        elif command -v "xclip" >/dev/null 2>&1; then
          printf '%s' "$video_link" | xclip -selection clipboard
          send_notification "Link copied to clipboard"
        elif command -v "xsel" >/dev/null 2>&1; then
          printf '%s' "$video_link" | xsel --clipboard --input
          send_notification "Link copied to clipboard"
        elif command -v "pbcopy" >/dev/null 2>&1; then
          printf '%s' "$video_link" | pbcopy
          send_notification "Link copied to clipboard"
        else
          send_notification "No clipboard tool found (install wl-copy, xclip, or xsel)"
        fi
        ;;
      Download)
        video_url=$(echo "$video" | jq '.url' -r)
        build_ytdlp_opts download
        yt-dlp "$video_url" --output "$DOWNLOAD_DIRECTORY/videos/individual/%(channel)s/%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}"
        send_notification "Completed downloading of $title"
        ;;
      "Download (Audio Only)")
        video_url=$(echo "$video" | jq '.url' -r)
        build_ytdlp_opts audio
        yt-dlp "$video_url" -x -f 'bestaudio' --audio-format mp3 --output "$DOWNLOAD_DIRECTORY/audio/individual/%(channel)s/%(title)s.%(ext)s" "${PREFERRED_BROWSER_OPTS[@]}" "${YTDLP_OPTS[@]}"
        send_notification "Completed downloading of $title"
        ;;
      Back)
        break
        ;;
      Shell)
        video_url=$(echo "$video" | jq '.url' -r)
        export url urlForAll search_results video video_url playlist_title CLI_HEADER CLI_NAME DOWNLOAD_DIRECTORY CLI_YT_DLP_ARCHIVE
        local init_text="\
$CLI_HEADER
Welcome to the $CLI_NAME shell.
You can use the following:
 variables:
    - url
    - urlForAll
    - search_results
    - video
    - video_url
    - playlist_title
    - DOWNLOAD_DIRECTORY
    - CLI_YT_DLP_ARCHIVE
  functions:
    - generate_sha256
"
        user_shell="$(ps -o comm= -p "$PPID")"
        if [ "$user_shell" = "fish" ]; then
          fish --init-command "function fish_greeting; clear;echo \"$init_text\"; end"
        else
          bash --rcfile <(echo "[ -f ~/.bashrc ] && . ~/.bashrc;clear;echo \"$init_text\"")
        fi

        ;;
      Exit)
        byebye
        ;;
      "")
        # Separator selected, skip
        ;;
      *)
        echo "Invalid action" >&2
        sleep "$NOTIFICATION_DURATION"
        ;;
      esac
      clear
    done
  done
  unset urlForAll
  unset search_results
  PLAYLIST_START="1"
  PLAYLIST_END="$NO_OF_SEARCH_RESULTS"
}
get_channels_data() {
  [ "$FORCE_CHANNEL_THUMBNAILS_DOWNLOAD" = "0" ] && download_preview_images "$channels_data"
  if [ -f "$CLI_CONFIG_DIR/subscriptions.json" ] && ! [ "$force_update" = "1" ]; then
    channels_data=$(cat "$CLI_CONFIG_DIR/subscriptions.json")
  else
    echo Loading subscriptions...
    if [ "${#PREFERRED_BROWSER_OPTS[@]}" -gt 0 ]; then
      channels_data=$(yt-dlp "https://www.youtube.com/feed/channels" --flat-playlist "${PREFERRED_BROWSER_OPTS[@]}" -J)
    else
      send_notification "Failed to fetch subscriptions (please set preferred browser in config)"
    fi
    ! [ "$FORCE_CHANNEL_THUMBNAILS_DOWNLOAD" = "0" ] && [ "$ENABLE_PREVIEW" = "true" ] && download_preview_images "$channels_data"
    [ -n "$channels_data" ] && ! [ "$channels_data" = "null" ] && echo "$channels_data" >"$CLI_CONFIG_DIR/subscriptions.json" || send_notification "Failed to fetch subscriptions"
    clear
  fi
}
playlists_explorer() {
  playlist_results=$(
    if command -v "gum" >/dev/null 2>&1; then
      gum spin --show-output -- yt-dlp "$url" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" "${PLAYLISTS_EXTRA_ARGS[@]}"
    else
      echo "Loading..." >&2
      yt-dlp "$url" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" "${PLAYLISTS_EXTRA_ARGS[@]}"
    fi
  )
  playlist_results=$(echo "$playlist_results" | jq "
          .entries=(.entries 
          | to_entries
          | map(.value.title=\"\(.key+1|tostring| if (.|length) < 2 then \"0\" + . else . end) \"+.value.title) 
          |map(.value))
          ")
  playlist_video_titles=$(echo "$playlist_results" | jq '.entries[].title' -r 2>/dev/null)
  [ "$ENABLE_PREVIEW" = "true" ] && [ "$PREFERRED_SELECTOR" = "fzf" ] && download_preview_images "$playlist_results"
  export playlist_results SHELL
  while true; do
    if [ "$ENABLE_PREVIEW" = "true" ]; then

      playlist_title="$(printf "%s\n${CYAN}󰌍${RESET}  Back\n${RED}󰈆${RESET}  Exit" "$playlist_video_titles" | launcher_with_preview "select video" "$PREVIEW_SCRIPT_FOR_VIDEOS" | tr -d '\n' | sed 's/^[^0-9]  //g')"
    else
      playlist_title="$(printf "%s\nBack\nExit" "$playlist_video_titles" | launcher "select video" | tr -d '\n' | sed 's/^[^0-9]  //g')"
    fi
    clear
    playlist_title="$(echo "$playlist_title" | sed 's/"/\\"/g')"
    case "$playlist_title" in
    *Back | "")
      break
      ;;
    *Exit)
      byebye
      ;;
    esac
    playlist_title="$(echo "$playlist_title" | sed 's/ *$//g' | tr -d "\n")"
    playlist="$(echo "$playlist_results" | jq --arg title "$playlist_title" '.entries | map(select(.title == $title)) | .[0]')"
    playlist_title="$(echo "$playlist_title" | sed 's/^.. //g')"
    url="$(echo "$playlist" | jq '.url' -r)"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
  done
}
channels_explorer() {
  while true; do
    channel_action="$(printf "\
${CYAN}󰕧${RESET}  Videos
${CYAN}󰩉${RESET}  Featured
${CYAN}󰍉${RESET}  Search
${GRAY}┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈${RESET}
${BLUE}󰐑${RESET}  Playlists
${BLUE}󱔓${RESET}  Shorts
${BLUE}󰠿${RESET}  Streams
${BLUE}󰦔${RESET}  Podcasts
${GRAY}┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈${RESET}
${PURPLE}󰵀${RESET}  Subscribe
${RED}󰌍${RESET}  Back
${RED}󰈆${RESET}  Exit
" | launcher "Select Action" | sed 's/^.[[:space:]]*//; s/[[:space:]]*$//' | xargs -r)"
    [ "$channel_action" = "Exit" ] && byebye
    [ "$channel_action" = "Back" ] && break
    [ -z "$channel_action" ] && continue  # Separator selected, skip
    uploader_url_base="$(echo "$channel" | jq '.uploader_url' -r)"

    case "$channel_action" in
    Videos)
      url="$uploader_url_base/videos"
      search_results=$(run_yt_dlp "$url")
      playlist_explorer
      ;;
    Streams)
      url="$uploader_url_base/streams"
      search_results=$(run_yt_dlp "$url")
      playlist_explorer
      ;;
    Podcasts)
      url="$uploader_url_base/podcasts"
      playlists_explorer
      ;;
    Shorts)
      url="$uploader_url_base/shorts"
      search_results=$(run_yt_dlp "$url")
      playlist_explorer
      ;;
    Featured)
      url="$uploader_url_base/featured"
      playlists_explorer
      ;;
    Playlists)
      url="$uploader_url_base/playlists"
      playlists_explorer
      ;;
    Search)
      clear
      search_term="$(prompt "Enter term to search for" | jq -Rr '@uri')"
      url="$uploader_url_base/search?query=$search_term"
      search_results=$(run_yt_dlp "$url")
      playlist_explorer
      ;;
    Subscribe)
      if ! [ -s "$CLI_CONFIG_DIR/subscriptions.json" ]; then
        if confirm "Would you like to import your youtube subscriptions first? You wont be able to do so again unless you delete subscriptions.json"; then
          _channels_data=$(yt-dlp "https://www.youtube.com/feed/channels" --flat-playlist "${PREFERRED_BROWSER_OPTS[@]}" -J)
          write_file_locked "$_channels_data" "$CLI_CONFIG_DIR/subscriptions.json"
        else
          _channels_data='{"entries":[]}'
        fi
      else
        _channels_data=$(read_file_locked "$CLI_CONFIG_DIR/subscriptions.json")
      fi

      updated_subs=$(echo "$_channels_data" | jq --argjson channel "$channel" '
        {entries: ([.entries[] | select(.id != $channel.id)] + [$channel])}
      ')
      write_file_locked "$updated_subs" "$CLI_CONFIG_DIR/subscriptions.json" && send_notification "successfully subscribed" || send_notification "Failed to subscribe to channel"
      ;;
    Exit)
      byebye
      ;;
    *)
      echo "Invalid channel action" >&2
      sleep "$NOTIFICATION_DURATION"
      ;;
    esac
    clear
  done

}
main() {
  SHELL="bash"
  clear
  case "${CMD_ACTION}" in
  Search)
    unset CMD_ACTION
    action="Search"
    ;;
  *)
    action="$(printf "\
${CYAN}󰋜${RESET}  Your Feed
${CYAN}󰍉${RESET}  Search
${GRAY}┈┈┈┈┈┈┈┈${RESET} ${DIM}Library${RESET} ${GRAY}┈┈┈┈┈┈┈┈${RESET}
${BLUE}󰐑${RESET}  Playlists
${BLUE}󰅐${RESET}  Watch Later
${BLUE}󰤥${RESET}  Liked Videos
${BLUE}󰃀${RESET}  Saved Videos
${BLUE}󰋚${RESET}  Watch History
${BLUE}󰋚${RESET}  Recent
${GRAY}┈┈┈┈┈┈${RESET} ${DIM}Subscriptions${RESET} ${GRAY}┈┈┈┈┈┈${RESET}
${PURPLE}󰵀${RESET}  Subscription Feed
${PURPLE}󰑈${RESET}  Channels
${GRAY}┈┈┈┈┈┈┈┈${RESET} ${DIM}Custom${RESET} ${GRAY}┈┈┈┈┈┈┈┈┈${RESET}
${ORANGE}󰲸${RESET}  Custom Playlists
${ORANGE}󰗀${RESET}  Clips
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Settings${RESET} ${GRAY}┈┈┈┈┈┈┈┈${RESET}
${GREEN}󰏫${RESET}  Edit Config
${GREEN}󰒓${RESET}  Settings
${RED}󰈆${RESET}  Exit" | launcher "Select Action" | sed 's/.*  //g')"
    ;;
  esac
  [ "$action" = "Exit" ] && byebye

  unset urlForAll
  case "$action" in
  "Your Feed")
    url="https://www.youtube.com"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  Search)
    clear
    PROMPT_CONTEXT="Search"
    if [ -z "$CMD_SEARCH_TERMS" ]; then
      search_term="$(prompt "Enter term to search for")"
      if [[ "$search_term" =~ ^![0-9]{1,2}$ ]]; then
        index="${search_term:1}" # remove the leading "!"
        history_item=$(tail -n 10 "$CLI_CACHE_DIR/search_history.txt" | tac | sed -n "${index}p")
        if [[ -n "$history_item" ]]; then
          echo "Using history item #$index: $history_item"
          search_term="$history_item"
        else
          echo "No such history item: $index"
        fi
      fi
      # Exit if user presses ESC or leaves search empty in rofi
      if [ "$PREFERRED_SELECTOR" = "rofi" ] && [ -z "$search_term" ]; then
        echo "Search cancelled. No search term provided."
        return 1
      fi
    else
      search_term="$CMD_SEARCH_TERMS"
      unset CMD_SEARCH_TERMS
    fi
    if [[ "$search_term" =~ ^(:[a-z]+)[[:space:]]+(.+) ]]; then
      search_filter="${BASH_REMATCH[1]}"
      search_term="${BASH_REMATCH[2]}"
      case "$search_filter" in
      ":hour") sp="EgIIAQ%253D%253D" ;;
      ":today") sp="EgIIAg%253D%253D" ;;
      ":week") sp="EgIIAw%253D%253D" ;;
      ":month") sp="EgIIBA%253D%253D" ;;
      ":year") sp="EgIIBQ%253D%253D" ;;
      ":video") sp="EgIQAQ%253D%253D" ;;
      ":movie") sp="EgIQBA%253D%253D" ;;
      ":live") sp="EgJAAQ%253D%253D" ;;
      ":short") sp="EgQQARgB" ;;
      ":long") sp="EgQQARgC" ;;
      ":4k") sp="EgJwAQ%253D%253D" ;;
      ":hd") sp="EgIgAQ%253D%253D" ;;
      ":subtitles") sp="EgIoAQ%253D%253D" ;;
      ":360") sp="EgJ4AQ%253D%253D" ;;
      ":vr") sp="EgLIAQ%253D%253D" ;;
      ":3d") sp="EgI4AQ%253D%253D" ;;
      ":hdr") sp="EgPIAQ%253D%253D" ;;
      ":local") sp="EgO4AQ%253D%253D" ;;
      ":newest") sp="CAISAhAB" ;;
      ":views") sp="CAMSAhAB" ;;
      ":rating") sp="CAESAhAB" ;;
      *) sp="EgIQAQ%253D%253D" ;;
      esac
    fi
    [ "$SEARCH_HISTORY" = "true" ] && [ -s "$CLI_CACHE_DIR/search_history.txt" ] && history=$(grep --invert-match "^$search_term\$" "$CLI_CACHE_DIR/search_history.txt")
    [ "$SEARCH_HISTORY" = "true" ] && [ -s "$CLI_CACHE_DIR/search_history.txt" ] && echo "$history" >"$CLI_CACHE_DIR/search_history.txt"
    [ "$SEARCH_HISTORY" = "true" ] && echo "$search_term" >>"$CLI_CACHE_DIR/search_history.txt"
    search_term=$(echo "$search_term" | jq -Rr '@uri')
    url="https://www.youtube.com/results?search_query=$search_term&sp=$sp"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  "Subscription Feed")
    url="https://www.youtube.com/feed/subscriptions"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  Playlists)
    url="https://www.youtube.com/feed/playlists"
    playlists_explorer
    ;;
  "Saved Videos")
    ! [ -s "$CLI_CONFIG_DIR/saved_videos.json" ] && echo No saved videos && sleep "$NOTIFICATION_DURATION" && main
    search_results=$(jq '{"entries":.entries|reverse}' "$CLI_CONFIG_DIR/saved_videos.json")
    playlist_explorer
    ;;
  Recent)
    ! [ -s "$CLI_CONFIG_DIR/recent.json" ] && echo No recent videos && sleep "$NOTIFICATION_DURATION" && main
    search_results=$(jq '{"entries":.entries|reverse}' "$CLI_CONFIG_DIR/recent.json")
    playlist_explorer
    ;;
  Channels)
    while true; do
      get_channels_data
      channels=$(echo "$channels_data" | jq '.entries[].channel' -r)
      export SHELL CLI_CONFIG_DIR
      channel_name=$(printf "%s\nMain Menu\nExit" "$channels" | launcher_with_preview "Select Channel" "$PREVIEW_SCRIPT_FOR_CHANNELS")
      channel_name="$(echo "$channel_name" | sed 's/ *$//g' | tr -d "\n")"
      [ "$channel_name" = "Exit" ] && byebye
      [ "$channel_name" = "Main Menu" ] && break
      channel="$(echo "$channels_data" | jq --arg name "$channel_name" '.entries | map(select(.channel == $name)) | .[0]')"
      channels_explorer
    done
    ;;
  Custom\ Playlists)
    ! [ -s "$CUSTOM_PLAYLISTS" ] && echo "You don't have any custom playlists. Create them here: <$CUSTOM_PLAYLISTS>" && sleep "$NOTIFICATION_DURATION" && main
    while true; do
      playlist_title=$(printf "%s\nBack" "$(jq -r '. | reverse | .[].name' "$CUSTOM_PLAYLISTS")" | launcher "Select Custom Playlist To Play")
      [ "$playlist_title" = "Back" ] || [ "$playlist_title" = "" ] && break
      url=$(jq -r --arg name "$playlist_title" 'map(select(.name == $name)) | .[0].playlistWatchUrl' "$CUSTOM_PLAYLISTS")
      urlForAll=$(jq -r --arg name "$playlist_title" 'map(select(.name == $name)) | .[0].playlistUrl' "$CUSTOM_PLAYLISTS")
      search_results=$(run_yt_dlp "$url")
      playlist_explorer
    done
    ;;
  "Liked Videos")
    url="https://www.youtube.com/playlist?list=LL"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  "Watch Later")
    url="https://www.youtube.com/playlist?list=WL"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  "Watch History")
    url="https://www.youtube.com/feed/history"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  Clips)
    url="https://www.youtube.com/feed/clips"
    search_results=$(run_yt_dlp "$url")
    playlist_explorer
    ;;
  "Edit Config")
    open_in_editor "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
    load_config
    ;;
  Settings)
    while true; do
      local preview_status
      [ "$ENABLE_PREVIEW" = "true" ] && preview_status="ON" || preview_status="OFF"
      action="$(printf "\
${GREEN}󰋲${RESET}  Toggle Previews [$preview_status]
${GREEN}󰔎${RESET}  Select Theme [${CURRENT_THEME:-default}]
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Explore${RESET} ${GRAY}┈┈┈┈┈┈┈┈${RESET}
${CYAN}󰵀${RESET}  Explore Channels
${CYAN}󰐑${RESET}  Explore Playlists
${CYAN}󱘢${RESET}  Search History
${GRAY}┈┈┈┈┈┈${RESET} ${DIM}Commands${RESET} ${GRAY}┈┈┈┈┈┈┈${RESET}
${ORANGE}󰆺${RESET}  New Custom Command
${ORANGE}󰡦${RESET}  Custom Commands
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Edit${RESET} ${GRAY}┈┈┈┈┈┈┈┈┈${RESET}
${BLUE}󱋢${RESET}  Edit Search History
${BLUE}󰤀${RESET}  Edit Custom Playlists
${BLUE}󱄢${RESET}  Edit MPV Config
${BLUE}󰮆${RESET}  Edit yt-dlp Config
${BLUE}󱘫${RESET}  Edit Custom Commands
${GRAY}┈┈┈┈┈┈┈${RESET} ${DIM}Sync${RESET} ${GRAY}┈┈┈┈┈┈┈┈┈${RESET}
${PURPLE}󰓦${RESET}  Sync YouTube Subscriptions
${PURPLE}󰏗${RESET}  Check yt-dlp Version
${RED}󰆴${RESET}  Clear Search History
${GRAY}┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈${RESET}
${RED}󰌍${RESET}  Back
${RED}󰈆${RESET}  Exit
" | launcher "Select Action" | sed 's/.*  //g')"
      case "$action" in
      Toggle\ Previews*)
        if [ "$ENABLE_PREVIEW" = "true" ]; then
          ENABLE_PREVIEW="false"
          send_notification "Previews disabled"
        else
          ENABLE_PREVIEW="true"
          send_notification "Previews enabled"
        fi
        # Update the config file
        if grep -q "^ENABLE_PREVIEW:" "$CLI_CONFIG_DIR/${CLI_NAME}.conf"; then
          sed_inplace "s/^ENABLE_PREVIEW:.*/ENABLE_PREVIEW: $ENABLE_PREVIEW/" "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
        else
          echo "ENABLE_PREVIEW: $ENABLE_PREVIEW" >> "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
        fi
        ;;
      Select\ Theme*)
        # Build theme list with current selection indicator
        local theme_list=""
        local available_themes
        available_themes=$(list_themes)
        while IFS= read -r theme; do
          if [ "$theme" = "$CURRENT_THEME" ]; then
            theme_list+="${GREEN}${RESET}  ${theme} ${DIM}(current)${RESET}\n"
          else
            theme_list+="${CYAN}󰔎${RESET}  ${theme}\n"
          fi
        done <<< "$available_themes"

        local selected_theme
        selected_theme=$(printf "%b" "$theme_list" | launcher "Select Theme" | sed 's/.*  //' | sed 's/ (current)//')

        if [ -n "$selected_theme" ]; then
          THEME="$selected_theme"
          # Update config file
          if grep -q "^THEME:" "$CLI_CONFIG_DIR/${CLI_NAME}.conf"; then
            sed_inplace "s/^THEME:.*/THEME: $THEME/" "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
          else
            echo "THEME: $THEME" >> "$CLI_CONFIG_DIR/${CLI_NAME}.conf"
          fi
          # Reload theme
          init_pretty_print
          send_notification "Theme changed to: $selected_theme"
        fi
        ;;
      Explore\ Channels)
        unset search_term
        while true; do
          clear
          [ -z "$search_term" ] && search_term=$(prompt "What channel would you like to explore?") && url="https://www.youtube.com/results?search_query=$search_term&sp=EgIQAg%253D%253D" && channels_data=$(
            if command -v "gum" >/dev/null 2>&1; then
              gum spin --show-output -- yt-dlp "$url" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" --playlist-start 1 --playlist-end "$NO_OF_SEARCH_RESULTS"
            else
              echo "Loading..." >&2
              yt-dlp "$url" -J --flat-playlist --extractor-args youtubetab:approximate_date "${PREFERRED_BROWSER_OPTS[@]}" --playlist-start 1 --playlist-end "$NO_OF_SEARCH_RESULTS"
            fi
          ) && download_preview_images "$channels_data"
          clear
          channels=$(echo "$channels_data" | jq '.entries[].channel' -r)
          export channels_data SHELL
          channel_name=$(printf "%s\nBack\nExit" "$channels" | launcher_with_preview "Select Channel" "$PREVIEW_SCRIPT_FOR_CHANNELS_EXPLORER")
          channel_name="$(echo "$channel_name" | sed 's/ *$//g' | tr -d "\n")"
          [ "$channel_name" = "Exit" ] && byebye
          [ "$channel_name" = "Back" ] || [ "$channel_name" = "" ] && break
          channel="$(echo "$channels_data" | jq --arg name "$channel_name" '.entries | map(select(.channel == $name)) | .[0]')"
          channels_explorer
        done
        unset channels_data
        ;;
      Explore\ Playlists)
        clear
        search_term=$(prompt "What playlist would you like to explore?")
        url="https://www.youtube.com/results?search_query=$search_term&sp=EgIQAw%253D%253D"
        PLAYLISTS_EXTRA_ARGS=(--playlist-start 1 --playlist-end "$NO_OF_SEARCH_RESULTS")
        playlists_explorer
        PLAYLISTS_EXTRA_ARGS=()
        ;;
      Search\ History)
        clear
        while true; do
          ! [ -s "$CLI_CACHE_DIR/search_history.txt" ] && echo "No search history or disabled" && sleep "$NOTIFICATION_DURATION" && main
          search_term="$(printf "$(tac "$CLI_CACHE_DIR/search_history.txt")\nBack" | launcher "Search for" | jq -Rr '@uri')"
          [ "$search_term" = "Back" ] || [ "$search_term" = "" ] && break
          url="https://www.youtube.com/results?search_query=$search_term&sp=EgIQAQ%253D%253D"
          search_results=$(run_yt_dlp "$url")
          playlist_explorer
        done
        ;;
      New\ Custom\ Command)
        clear
        custom_yt_dlp_cmd=$(prompt "Enter the custom yt-dlp command" "yt-dlp -J --flat-playlist --extractor-args youtubetab:approximate_date ${PREFERRED_BROWSER_OPTS[*]} https://youtube.com")
        custom_cmds="[]"
        [ -s "$F_CUSTOM_CMDS" ] && custom_cmds=$(cat "$F_CUSTOM_CMDS")
        custom_cmd_name=$(prompt "Enter the name of the new custom command")
        echo "$custom_cmds" | jq --arg name "$custom_cmd_name" --arg cmd "$custom_yt_dlp_cmd" \
          '. += [{name: $name, cmd: $cmd}]' \
          >"$F_CUSTOM_CMDS" && send_notification "successfully added to custom cmds" || send_notification "Failed to add to custom cmds"

        echo Running new custom command...
        search_results=$(
          if command -v "gum" >/dev/null 2>&1; then
            gum spin --show-output --show-error -- $custom_yt_dlp_cmd || send_notification "Failed to fetch data : ("
          else
            echo "Loading..." >&2
            $custom_yt_dlp_cmd || send_notification "Failed to fetch data : ("
          fi
        )

        playlist_explorer
        ;;
      Custom\ Commands)
        ! [ -s "$F_CUSTOM_CMDS" ] && send_notification "You dont have any custom cmds. Create them here: <$F_CUSTOM_CMDS>"
        while true; do
          custom_cmd_name=$(printf "%s\nBack" "$(jq -r '.[].name' "$F_CUSTOM_CMDS")" | launcher "Select Custom Data Loader Command To Run")
          [ "$custom_cmd_name" = "Back" ] || [ "$custom_cmd_name" = "" ] && break
          custom_yt_dlp_cmd=$(jq -r --arg name "$custom_cmd_name" 'map(select(.name == $name)) | .[0].cmd' "$F_CUSTOM_CMDS")
          echo Running custom command...
          search_results=$(
            if command -v "gum" >/dev/null 2>&1; then
              gum spin --show-output --show-error -- $custom_yt_dlp_cmd || send_notification "Failed to fetch data : ("
            else
              echo "Loading..." >&2
              $custom_yt_dlp_cmd || send_notification "Failed to fetch data : ("
            fi
          )
          playlist_explorer
        done
        ;;
      Edit\ Search\ History)
        open_in_editor "$CLI_CACHE_DIR/search_history.txt"
        ;;
      Edit\ Custom\ Playlists)
        open_in_editor "$CLI_CONFIG_DIR/custom_playlists.json"
        ;;
      Edit\ Custom\ Commands)
        open_in_editor "$F_CUSTOM_CMDS"
        ;;
      Edit\ MPV\ Config)
        open_in_editor "${XDG_CONFIG_HOME:-"$HOME"/.config}/mpv/mpv.conf"
        ;;
      "Edit yt-dlp Config")
        open_in_editor "${XDG_CONFIG_HOME:-"$HOME"/.config}/yt-dlp/config/yt-dlp.conf"
        ;;
      Clear\ Search\ History)
        confirm "Are you sure you want to clear your search history ($CLI_CACHE_DIR/search_history.txt)?" && rm "$CLI_CACHE_DIR/search_history.txt"
        ;;
      Sync\ YouTube\ Subscriptions)
        if confirm "This will erase your local subs, proceed?"; then
          echo "Syncing subscriptions..."
          if [ "${#PREFERRED_BROWSER_OPTS[@]}" -gt 0 ]; then
            channels_data=$(yt-dlp "https://www.youtube.com/feed/channels" --flat-playlist "${PREFERRED_BROWSER_OPTS[@]}" -J)
          else
            send_notification "Failed to fetch subscriptions (please set preferred browser in config)"
          fi
          download_preview_images "$channels_data"
          [ -n "$channels_data" ] && ! [ "$channels_data" = "null" ] && echo "$channels_data" >"$CLI_CONFIG_DIR/subscriptions.json" && send_notification "successfully imported yt subs" || send_notification "Failed to fetch subscriptions"
        else
          send_notification "Sync cancelled"
        fi
        ;;
      Check\ yt-dlp\ Version)
        check_ytdlp_version
        read -r -p "Press Enter to continue..."
        ;;
      Back)
        break
        ;;
      Exit)
        byebye
        ;;
      "")
        break
        ;;
      *)
        echo "Invalid action" >&2
        sleep "$NOTIFICATION_DURATION"
        ;;
      esac
    done
    ;;
  Exit)
    byebye
    ;;
  "")
    # Separator selected, skip
    ;;
  *)
    echo "Invalid action" >&2
    sleep "$NOTIFICATION_DURATION"
    ;;
  esac
  main
}

usage() {
  printf "\
A script written to browse youtube from the terminal

Usage: %s [arguments] [options] 

Commandline options override the config

Options:
  -S, --search [Search Terms]
    search for a video
  -e, --edit-config
    edit $CLI_NAME config file
  --rofi-theme <path>
    set the path to your rofi config file
  --disown-streaming-process
    disown the streaming process so you can contine streaming even if you close $CLI_NAME
  --no-disown-streaming-process
    don't disown the streaming process
  --disown-downloading-process
    disown the downloading process so you can contine streaming even if you close $CLI_NAME
  --no-disown-downloading-process
    don't disown the downloading process
  -s <selector>,--preferred-selector <selector> [fzf/rofi]
    set the preferred selector for $CLI_NAME to use
  -p <player>,--player <player> [mpv/vlc]
    set the video player for $CLI_NAME to use
  -x <extension>,--extension <extension> [name of extension file at $CLI_EXTENSION_DIR or full path]
    set the extension for $CLI_NAME to use (accepts full path starting with /)
  --preview
    enable the preview window
  --no-preview
    disable the preview window
  --theme <name>
    set the color theme (e.g., everforest-dark-hard, tokyo-night, catppuccin-mocha)
  --list-themes
    list all available themes and exit
  -E, --generate-desktop-entry
    print the desktop entry and exit
  --check-deps
    check all dependencies and show their status
  --install
    install missing dependencies using system package manager
  --install-self [path]
    install $CLI_NAME to system (default: /usr/local/bin)
  -h, --help
    Show this help message and exit
  -v, --version
    print the $CLI_NAME version and exit

arguments:
  completions
    generates shell completions for $CLI_NAME

Examples:
  $CLI_NAME --generate-desktop-entry
  $CLI_NAME completions --fish 
" "$CLI_NAME"
  exit "$1"
}

# load config and default vars
load_config
force_update=0
CURRENT_TIME=$(date +%s)

while [ $# -gt 0 ]; do
  case "$1" in
  -h | --help)
    usage 0
    ;;
  -v | --version)
    echo "$CLI_NAME v$CLI_VERSION Copyright © 2024 $CLI_AUTHOR projects"
    exit 0
    ;;
  -e | --edit-config)
    open_in_editor "$CLI_CONFIG_DIR/${CLI_NAME}.conf" || exit 1
    byebye
    ;;
  -U | --update)
    check_update "A new version of $CLI_NAME has been found would you like to upgrade? (y/n)"
    exit 0
    ;;
  -S | --search)
    CMD_ACTION="Search"
    CMD_SEARCH_TERMS="$2"
    shift
    ;;
  -s | --preferred-selector)
    [ -n "$2" ] || usage 1
    PREFERRED_SELECTOR="$2"
    shift
    ;;
  --preview)
    ENABLE_PREVIEW="true"
    ;;
  --no-preview)
    ENABLE_PREVIEW="false"
    ;;
  --theme)
    [ -n "$2" ] || { echo "Error: --theme requires a theme name"; usage 1; }
    THEME="$2"
    shift
    ;;
  --list-themes)
    echo "Available themes:"
    list_themes | while read -r theme; do
      if [ "$theme" = "${THEME:-everforest-dark-hard}" ]; then
        echo "  * $theme (current)"
      else
        echo "    $theme"
      fi
    done
    exit 0
    ;;
  --check-deps)
    check_dependencies
    exit $?
    ;;
  --install)
    install_dependencies
    exit 0
    ;;
  --install-self)
    install_path="${2:-/usr/local/bin}"
    if [ -n "$2" ] && [[ ! "$2" =~ ^- ]]; then
      shift
    fi
    install_self "$install_path"
    exit 0
    ;;
  --disown-streaming-process)
    DISOWN_STREAMING_PROCESS="true"
    ;;
  --no-disown-streaming-process)
    DISOWN_STREAMING_PROCESS="false"
    ;;
  --disown-downloading-process)
    DISOWN_DOWNLOADING_PROCESS="true"
    ;;
  --no-disown-downloading-process)
    DISOWN_DOWNLOADING_PROCESS="false"
    ;;
  --rofi-theme)
    [ -n "$2" ] || usage 1
    ROFI_THEME="$2"
    shift
    ;;
  -p | --player)
    [ -n "$2" ] || usage 1
    PLAYER="$2"
    shift
    ;;
  -E | --generate-desktop-entry)
    echo "
[Desktop Entry]
Name=$CLI_NAME
Type=Application
version=$CLI_VERSION
Path=$HOME
Comment=Browse Youtube from the terminal
Terminal=false
Icon=$CLI_DIR/assets/logo.png
Exec=$0 --preferred-selector rofi
Categories=Education
    "
    exit 0
    ;;
  completions)
    [ -n "$2" ] || usage 1
    case "$2" in
    -f | --fish)
      echo "\
# --- completions ---
complete -c $CLI_NAME --no-files --arguments \"completions\" --condition 'not __fish_contains_opt sort-by S e edit-config s preferred-selector  E generate-desktop-entry rofi-theme'

complete -c $CLI_NAME --no-files --short-option h --long-option help --description 'Print a short help text and exit'
complete -c $CLI_NAME --no-files --short-option v --long-option version --description 'Print a short version string and exit' --condition 'not __fish_seen_subcommand_from completions'

complete -c $CLI_NAME --no-files --short-option e --long-option edit-config --description 'Edit $CLI_NAME config file' --condition 'not __fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option U --long-option update --description 'update the script' --condition 'not __fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option p --long-option player --description 'the video player to use' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments 'mpv vlc'
complete -c $CLI_NAME --no-files --short-option x --long-option extension --description 'The extension to use' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments \"(command ls $CLI_EXTENSION_DIR)\"
complete -c $CLI_NAME --no-files --short-option s --long-option preferred-selector --description 'your preferred selector' --condition 'not __fish_seen_subcommand_from completions' --exclusive --arguments 'fzf rofi'
complete -c $CLI_NAME --no-files --short-option E --long-option generate-desktop-entry --description 'generate desktop entry info' --condition 'not __fish_seen_subcommand_from completions' 

complete -c $CLI_NAME --no-files --long-option preview --description 'enable preview window' --condition 'not __fish_seen_subcommand_from completions' 
complete -c $CLI_NAME --no-files --long-option no-preview --description 'disable preview window' --condition 'not __fish_seen_subcommand_from completions' 

complete -c $CLI_NAME --force-files --long-option rofi-theme --description 'the path to your rofi config file' --condition 'not __fish_seen_subcommand_from completions' 

complete -c $CLI_NAME --no-files --short-option S --long-option search --description 'the terms you want to search' --condition 'not __fish_seen_subcommand_from completions'

complete -c $CLI_NAME --no-files --long-option check-deps --description 'check all dependencies and show their status' --condition 'not __fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --long-option install --description 'install missing dependencies' --condition 'not __fish_seen_subcommand_from completions'
complete -c $CLI_NAME --force-files --long-option install-self --description 'install yt-x to system' --condition 'not __fish_seen_subcommand_from completions'

complete -c $CLI_NAME --no-files --short-option z --long-option zsh --description 'print zsh completions' --condition '__fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option b --long-option bash --description 'print bash completions' --condition '__fish_seen_subcommand_from completions'
complete -c $CLI_NAME --no-files --short-option f --long-option fish --description 'print fish completions' --condition '__fish_seen_subcommand_from completions'
    "
      ;;
    -b | --bash)
      # TODO: write bash completions
      echo Contribute to $CLI_NAME by writing bash completions
      ;;
    -z | --zsh)
      # TODO: write zsh completions
      echo Contribute to $CLI_NAME by writing zsh completions
      ;;
    -h | --help)
      echo "\
Generate shell completions for $CLI_NAME

Options:
  --fish
    print fish completions and exit
  --bash
    print bash completions and exit
  --zsh
    print zsh completions and exit

Example:
  $CLI_NAME completions --fish
  $CLI_NAME completions --bash
  $CLI_NAME completions --zsh
    "
      ;;
    *)
      echo "\
Generate shell completions for $CLI_NAME

Options:
  --fish
    print fish completions and exit
  --bash
    print bash completions and exit
  --zsh
    print zsh completions and exit

Example:
  $CLI_NAME completions --fish
  $CLI_NAME completions --bash
  $CLI_NAME completions --zsh
    "
      exit 1
      ;;

    esac
    exit 0
    ;;
  -x | --extension)
    [ -n "$2" ] || usage 1
    if [ "${2#/}" != "$2" ]; then
      . "$2"
    else
      . "$CLI_EXTENSION_DIR/$2"
    fi
    shift
    ;;
  *)
    usage 1
    ;;
  esac
  shift
done

# Check for updates if enabled
if [ "$UPDATE_CHECK" = "true" ]; then
  # setup for ui
  timestamp_file="$CLI_CACHE_DIR/.last_update_check"

  # Time interval in seconds (6 hours = 21600 seconds)
  interval=$((6 * 60 * 60))

  # Determine whether to run the update check
  current_time=$(date +%s)
  last_check_time=$(cat "$timestamp_file" 2>/dev/null || echo 0)

  if ((current_time - last_check_time >= interval)); then
    check_update "A new version of $CLI_NAME has been found would you like to upgrade? (y/n)"
    echo "$current_time" >"$timestamp_file"
  fi
fi
if [ "$WELCOME_SCREEN" = "true" ]; then
  # setup for ui
  timestamp_file="$CLI_CACHE_DIR/.last_welcome"

  # Time interval in seconds (30dys)
  interval=$((30 * 24 * 60 * 60))

  # Determine whether to run the update check
  current_time=$(date +%s)
  last_check_time=$(cat "$timestamp_file" 2>/dev/null || echo 0)

  if ((current_time - last_check_time >= interval)); then
    welcome
    echo "$current_time" >"$timestamp_file"
  fi
fi
core_dep_ch
check_ytdlp_version

# exports
export -f generate_sha256 fzf_preview

main
